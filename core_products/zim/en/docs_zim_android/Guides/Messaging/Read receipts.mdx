---
articleID: 15107
---

import {getPlatformData} from "/snippets/utils-content-parser.js"

export const ZIMMessageSendConfigMap = {
  'Android': <a href='@-ZIMMessageSendConfig' target='_blank'>ZIMMessageSendConfig</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessageSendConfig-class.html' target='_blank'>ZIMMessageSendConfig</a>,
}
export const sendMessageMap = {
  'Android': <a href='@sendMessage' target='_blank'>sendMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendMessage.html' target='_blank'>sendMessage</a>,
}
export const sendMediaMessageMap = {
  'Android': <a href='@sendMediaMessage' target='_blank'>sendMediaMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendMediaMessage.html' target='_blank'>sendMediaMessage</a>,
}
export const onPeerMessageReceivedMap = {
  'Android': <a href='@onPeerMessageReceived' target='_blank'>onPeerMessageReceived</a>,
  'Web': <a href='@peerMessageReceived' target='_blank'>peerMessageReceived</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onPeerMessageReceived.html' target='_blank'>onPeerMessageReceived</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-peer-message-received-from-user-id' target='_blank'>peerMessageReceived</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-peer-message-received-from-user-id' target='_blank'>peerMessageReceived</a>,
}
export const onGroupMessageReceivedMap = {
  'Android': <a href='@onGroupMessageReceived' target='_blank'>onGroupMessageReceived</a>,
  'Web': <a href='@groupMessageReceived' target='_blank'>groupMessageReceived</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onGroupMessageReceived.html' target='_blank'>onGroupMessageReceived</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-group-message-received-from-group-id' target='_blank'>groupMessageReceived</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-group-message-received-from-group-id' target='_blank'>groupMessageReceived</a>,
}
export const sendMessageReceiptsReadMap = {
  'Android': <a href='@sendMessageReceiptsRead' target='_blank'>sendMessageReceiptsRead</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendMessageReceiptsRead.html' target='_blank'>sendMessageReceiptsRead</a>,
}
export const ZIMMessageReceiptsReadSentCallbackMap = {
  'Android': <a href='@-ZIMMessageReceiptsReadSentCallback' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
  'Web': <a href='@-ZIMMessageReceiptsReadSentResult' target='_blank'>ZIMMessageReceiptsReadSentResult</a>,
  'U3d': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~cs_unity3d~interface~ZIMDefines#zim-message-receipts-read-sent-callback' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessageReceiptsReadSentResult-class.html' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
  'iOS,mac,window': <a href='@ZIMMessageReceiptsReadSentCallback' target='_blank'>ZIMMessageReceiptsReadSentCallback</a>,
}
export const onMessageReceiptChangedMap = {
  'Android': <a href='@onMessageReceiptChanged' target='_blank'>onMessageReceiptChanged</a>,
  'Web': <a href='@messageReceiptChanged' target='_blank'>messageReceiptChanged</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onMessageReceiptChanged.html' target='_blank'>onMessageReceiptChanged</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-message-receipt-changed' target='_blank'>messageReceiptChanged</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-message-receipt-changed' target='_blank'>messageReceiptChanged</a>,
}
export const ZIMEventHandlerMap = {
  'Android': <a href='@-ZIMEventHandler' target='_blank'>ZIMEventHandler</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler-class.html' target='_blank'>ZIMEventHandler</a>,
}
export const sendConversationMessageReceiptReadMap = {
  'Android': <a href='@sendConversationMessageReceiptRead' target='_blank'>sendConversationMessageReceiptRead</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/sendConversationMessageReceiptRead.html' target='_blank'>sendConversationMessageReceiptRead</a>,
}
export const ZIMConversationMessageReceiptReadSentCallbackMap = {
  'Android': <a href='@-ZIMConversationMessageReceiptReadSentCallback' target='_blank'>ZIMConversationMessageReceiptReadSentCallback</a>,
  'Web': <a href='@-ZIMConversationMessageReceiptReadSentResult' target='_blank'>ZIMConversationMessageReceiptReadSentResult</a>,
  'U3d': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~cs_unity3d~interface~ZIMDefines#zim-conversation-message-receipt-read-sent-callback' target='_blank'>ZIMConversationMessageReceiptReadSentCallback</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMConversationMessageReceiptReadSentResult-class.html' target='_blank'>ZIMConversationMessageReceiptReadSentResult</a>,
  'iOS,mac,window': <a href='@ZIMConversationMessageReceiptReadSentCallback' target='_blank'>ZIMConversationMessageReceiptReadSentCallback</a>,
}
export const onConversationMessageReceiptChangedMap = {
  'Android': <a href='@onConversationMessageReceiptChanged' target='_blank'>onConversationMessageReceiptChanged</a>,
  'Web': <a href='@conversationMessageReceiptChanged' target='_blank'>conversationMessageReceiptChanged</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onConversationMessageReceiptChanged.html' target='_blank'>onConversationMessageReceiptChanged</a>,
  'iOS': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-conversation-message-receipt-changed' target='_blank'>conversationMessageReceiptChanged</a>,
  'mac': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-conversation-message-receipt-changed' target='_blank'>conversationMessageReceiptChanged</a>,
}
export const queryMessageReceiptsInfoMap = {
  'Android': <a href='@queryMessageReceiptsInfo' target='_blank'>queryMessageReceiptsInfo</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryMessageReceiptsInfo.html' target='_blank'>queryMessageReceiptsInfo</a>,
  'iOS,mac': <a href='@queryMessageReceiptsInfoByMessageList' target='_blank'>queryMessageReceiptsInfoByMessageList</a>,
}
export const ZIMMessageReceiptsInfoQueriedCallbackMap = {
  'Android': <a href='@-ZIMMessageReceiptsInfoQueriedCallback' target='_blank'>ZIMMessageReceiptsInfoQueriedCallback</a>,
  'Web': <a href='@-ZIMMessageReceiptsInfoQueriedResult' target='_blank'>ZIMMessageReceiptsInfoQueriedResult</a>,
  'U3d': <a href='https://docs.zegocloud.com/article/api?doc=zim_API~cs_unity3d~interface~ZIMDefines#zim-message-receipts-info-queried-callback' target='_blank'>ZIMMessageReceiptsInfoQueriedCallback</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessageReceiptsInfoQueriedResult-class.html' target='_blank'>ZIMMessageReceiptsInfoQueriedResult</a>,
  'iOS,mac,window': <a href='@ZIMMessageReceiptsInfoQueriedCallback' target='_blank'>ZIMMessageReceiptsInfoQueriedCallback</a>,
}
export const queryGroupMessageReceiptReadMemberListMap = {
  'Android': <a href='@queryGroupMessageReceiptReadMemberList' target='_blank'>queryGroupMessageReceiptReadMemberList</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryGroupMessageReceiptUnreadMemberList.html' target='_blank'>queryGroupMessageReceiptReadMemberList</a>,
  'iOS,mac': <a href='@queryGroupMessageReceiptReadMemberListByMessage' target='_blank'>queryGroupMessageReceiptReadMemberListByMessage</a>,
}
export const queryGroupMessageReceiptUnreadMemberListMap = {
  'Android': <a href='@queryGroupMessageReceiptUnreadMemberList' target='_blank'>queryGroupMessageReceiptUnreadMemberList</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryGroupMessageReceiptReadMemberList.html' target='_blank'>queryGroupMessageReceiptUnreadMemberList</a>,
  'iOS,mac': <a href='@queryGroupMessageReceiptUnreadMemberListByMessage' target='_blank'>queryGroupMessageReceiptUnreadMemberListByMessage</a>,
}
export const ZIMTextMessageMap = {
  'Android': <a href='@-ZIMTextMessage' target='_blank'>ZIMTextMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMTextMessage-class.html' target='_blank'>ZIMTextMessage</a>,
}
export const ZIMMultipleMessageMap = {
  'Android': <a href='@-ZIMMultipleMessage' target='_blank'>ZIMMultipleMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMultipleMessage-class.html' target='_blank'>ZIMMultipleMessage</a>,
}
export const ZIMImageMessageMap = {
  'Android': <a href='@-ZIMImageMessage' target='_blank'>ZIMImageMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMImageMessage-class.html' target='_blank'>ZIMImageMessage</a>,
}
export const ZIMFileMessageMap = {
  'Android': <a href='@-ZIMFileMessage' target='_blank'>ZIMFileMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMFileMessage-class.html' target='_blank'>ZIMFileMessage</a>,
}
export const ZIMAudioMessageMap = {
  'Android': <a href='@-ZIMAudioMessage' target='_blank'>ZIMAudioMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMAudioMessage-class.html' target='_blank'>ZIMAudioMessage</a>,
}
export const ZIMVideoMessageMap = {
  'Android': <a href='@-ZIMVideoMessage' target='_blank'>ZIMVideoMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMVideoMessage-class.html' target='_blank'>ZIMVideoMessage</a>,
}
export const ZIMCombineMessageMap = {
  'Android': <a href='@-ZIMCombineMessage' target='_blank'>ZIMCombineMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMCombineMessage-class.html' target='_blank'>ZIMCombineMessage</a>,
}

# Read receipts
- - -

:::if{props.platform="U3d"}
<Note title="Note">

This document is applicable to the following platforms of Unity framework: iOS, Android, macOS, and Windows.
</Note>
:::

## Overview

Message reading receipt helps users know whether other users have read the messages they sent in a conversation. This feature applies to enterprise office businesses and other scenarios in which the message reading status needs to be known in real time.

This document describes how to use APIs of the In-app Chat SDK to send messages that require a reading receipt, query the receipt status of messages, and set messages as read.

<Warning title="Warning">

The In-app Chat SDK supports reading receipts for one-to-one messages and group messages (only common messages and rich media messages) and does not support reading receipts for in-room messages.

</Warning>

## Implementation process

The sender sends a message through the In-app Chat SDK and sets the `hasReceipt` field of {getPlatformData(props,ZIMMessageSendConfigMap)} to identify whether a reading receipt is required for the message. Based on the `receiptStatus` field, the receiver determines whether a reading receipt is required for the message or whether the message is read or unread to render different UI effects. The message receiver can use different reading methods based on the scenario.

### Send a message that requires a reading receipt

When Client A wants to send a message that requires a reading receipt to Client B:
1. Client A and Client B log in to the In-app Chat service.
2. Client A calls the {getPlatformData(props,sendMessageMap)} or {getPlatformData(props,sendMediaMessageMap)} API to send a message (common message or rich media message in one-to-one or group chats) to Client B and sets the `hasReceipt` field of {getPlatformData(props,ZIMMessageSendConfigMap)} to **true**.
:::if{props.platform="undefined|Flutter|iOS|mac|window|Web"}
<div>
2. Client A calls the {getPlatformData(props,sendMessageMap)} or {getPlatformData(props,sendMediaMessageMap)} API to send a message to Client B (only supports {getPlatformData(props,ZIMTextMessageMap)}, {getPlatformData(props,ZIMImageMessageMap)}, {getPlatformData(props,ZIMFileMessageMap)}, {getPlatformData(props,ZIMAudioMessageMap)}, {getPlatformData(props,ZIMVideoMessageMap)}, {getPlatformData(props,ZIMCombineMessageMap)}, and {getPlatformData(props,ZIMMultipleMessageMap)} in "one-to-one" chats and "group" chats), and sets the `hasReceipt` field of {getPlatformData(props,ZIMMessageSendConfigMap)} to true;
</div>
:::
:::if{props.platform="U3d"}
<div>
2. Client A calls the {getPlatformData(props,sendMessageMap)} or {getPlatformData(props,sendMediaMessageMap)} API to send a message to Client B (only supports {getPlatformData(props,ZIMTextMessageMap)}, {getPlatformData(props,ZIMImageMessageMap)}, {getPlatformData(props,ZIMFileMessageMap)}, {getPlatformData(props,ZIMAudioMessageMap)}, and {getPlatformData(props,ZIMVideoMessageMap)} in "one-to-one" chats and "group" chats), and sets the `hasReceipt` field of {getPlatformData(props,ZIMMessageSendConfigMap)} to true;
</div>
:::
3. By listening for related callback ({getPlatformData(props,onPeerMessageReceivedMap)} or {getPlatformData(props,onGroupMessageReceivedMap)}), Client B receives a message whose `receiptStatus` is set to `PROCESSING`.

### Set the reading receipt status as read

In this operation, `set a message as read` and `set a conversation as read` are both supported.

#### Set a message as read

The receiver can set a message that requires a reading receipt from the sender as read. Then, the sender will receive a message read notification.

<Warning title="Warning">

- A single message or a batch of messages are supported. The sender and receiver must be in the same conversation. Cross-conversation operations are not supported.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](./Get%20message%20history.mdx).
</Warning>

1. Through related callback ({getPlatformData(props,onPeerMessageReceivedMap)} or {getPlatformData(props,onGroupMessageReceivedMap)}), Client B receives a message that requires a reading receipt from Client A.
2. Based on the `receiptStatus` field of the callback, Client B determines the receipt status of the message. If this field is set to `PROCESSING`, the message is unread. Developers can call the {getPlatformData(props,sendMessageReceiptsReadMap)} API to set the message as read based on the service logic.
3. Client B determines whether the setting is successful based on {getPlatformData(props,ZIMMessageReceiptsReadSentCallbackMap)}.
4. Based on {getPlatformData(props,onMessageReceiptChangedMap)} of {getPlatformData(props,ZIMEventHandlerMap)}, Client A receives a callback notification, indicating that the message is set as read. Developers can implement the service logic of setting the message as read on Client A based on this callback.


#### Set a conversation as read

The receiver can set all messages **received** from the sender in a specified conversation as read.

<Warning title="Warning">

- The In-app Chat SDK supports this feature only in **one-to-one chats**.  
- This feature takes effect only on messages received before setting the feature. 
- It is recommended that this feature be used when a user switches from the conversation list page to a conversation. It is not recommended that this feature be used together with the {getPlatformData(props,sendMessageReceiptsReadMap)} API on a message chat page.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](./Get%20message%20history.mdx).
</Warning>

1. Based on the `receiptStatus` field of the {getPlatformData(props,onPeerMessageReceivedMap)} callback, Client B determines the receipt status of the message. If this field is set to `PROCESSING`, the message is unread. Developers can call the {getPlatformData(props,sendConversationMessageReceiptReadMap)} API to set all messages sent by Client A in the conversation as read based on the service logic.
2. Client B determines whether the setting is successful based on {getPlatformData(props,ZIMConversationMessageReceiptReadSentCallbackMap)} .
3. Based on {getPlatformData(props,onConversationMessageReceiptChangedMap)} of {getPlatformData(props,ZIMEventHandlerMap)} , Client A receives a callback notification, indicating that all messages in the conversation are set as read. Developers can implement the logic of setting all messages sent from the sender in the conversation as read based on this callback. Developers can implement the service logic of knowing all sent messages in a conversation are set as read by Client B on Client A based on this callback.

## More features

### Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message

To query the message receipt status, the number of users who have read the message, and the number of users who have not read the message of a message or a batch of messages, call the {getPlatformData(props,queryMessageReceiptsInfoMap)} API. Call {getPlatformData(props,ZIMMessageReceiptsInfoQueriedCallbackMap)} to obtain related information.

<Warning title="Warning">

- If messages sent by other users are queried, the number of users who have read the message and the number of users who have not read the message are **0**.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](./Get%20message%20history.mdx).
</Warning>

### Query the list of members who have or have not read a group message

The In-app Chat SDK supports querying the list of members who have or have not read a group message.

#### Query the list of members who have read a group message

To query the list of members who have read a group message, call the {getPlatformData(props,queryGroupMessageReceiptReadMemberListMap)} API.

<Warning title="Warning">

To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](./Get%20message%20history.mdx).
</Warning>

#### Query the list of members who have not read a group message

To query the list of members who have not read a group message, call the {getPlatformData(props,queryGroupMessageReceiptUnreadMemberListMap)} API.

<Warning title="Warning">

- If the SDK version is older than 2.16.0, when the number of group members is greater than 100, this API will not return the list of members who have not read a group message. To use this feature, contact ZEGOCLOUD technical support.
  
- To perform operations on the historical messages of the conversation, you need to get the historical messages and determine the receipt status of the historical messages. For details, see [Get message history](./Get%20message%20history.mdx).
</Warning>

## Sample code

:::if{props.platform=undefined}
```java
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onMessageReceiptChanged(ZIM zim, ArrayList<ZIMMessageReceiptInfo> infos) {
        // The other user sets a message as read.
    }
    @Override
    public void onConversationMessageReceiptChanged(ZIM zim, ArrayList<ZIMMessageReceiptInfo> infos) {
        // The other user sets all messages in a conversation as read.
    }
})

// User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

String conversationID = "xxx" ; // The conversation ID

ZIMTextMessage message = new ZIMTextMessage("test");
ZIMMessageSendConfig sendConfig = new ZIMMessageSendConfig();
sendConfig.hasReceipt = true;    // Set that the messages require a reading receipt.
zim.sendMessage(message, conversationID, ZIMConversationType.PEER,sendConfig, new ZIMMessageSentCallback() {
            @Override
            public void onMessageAttached(ZIMMessage message) {}
            @Override
            public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                    // This indicates that the message is sent successfully. receiptStatus of the message is set to PROCESSING. The service layer can display the logic that a message is unread based on this flag.
                }
            }
        });

// User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// Set a message as read

List<ZIMMessage> messages = new ArrayList<>();
messages.add(message);
zim.sendMessageReceiptsRead(messages, conversationID, ZIMConversationType.PEER, 
        new ZIMMessageReceiptsReadSentCallback() {
            @Override
            public void onMessageReceiptsReadSent(String conversationID, ZIMConversationType conversationType, 
ArrayList<Long> errorMessageIDs, ZIMError errorInfo) {
             if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                // Callback for setting a message as read.
             }
            }
        });

// Set a conversation as read

zim.sendConversationMessageReceiptRead(conversationID, ZIMConversationType.PEER, 
            new ZIMConversationMessageReceiptReadSentCallback() {
            @Override
            public void onConversationMessageReceiptReadSent(String conversationID, 
                ZIMConversationType conversationType, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                    // A conversation is read. Developers can listen for this callback to set all messages sent by the sender in this conversation as read.
                }
            }
        });

// (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.

List<ZIMMessage> messages = new ArrayList<>();
messages.add(message);
zim.queryMessageReceiptsInfo(messages, conversationID, ZIMConversationType.PEER, new ZIMMessageReceiptsInfoQueriedCallback() {
            @Override
            public void onMessageReceiptsInfoQueried(ArrayList<ZIMMessageReceiptInfo> infos, 
                ArrayList<Long> errorMessageIDs, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                    // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
                }
            }
        });
// (Optional) Query the list of members who have or have not read a group message.

// The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
zim.queryGroupMessageReceiptReadMemberList(message, groupID, config, 
    new ZIMGroupMessageReceiptMemberListQueriedCallback() {
            @Override
            public void onGroupMessageReceiptMemberListQueried(String groupID, ArrayList<ZIMGroupMemberInfo> userList,
             int nextFlag, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                   // The corresponding member list is queried.
                }
            }
        });

// The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.

zim.queryGroupMessageReceiptUnreadMemberList(message, groupID, config, 
    new ZIMGroupMessageReceiptMemberListQueriedCallback() {
            @Override
            public void onGroupMessageReceiptMemberListQueried(String groupID, ArrayList<ZIMGroupMemberInfo> userList,
             int nextFlag, ZIMError errorInfo) {
                if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                   // The corresponding member list is queried.
                }
            }
        });
```
:::

:::if{props.platform="iOS|mac"}
```objc
- (void)zim:(ZIM *)zim messageReceiptChanged:(NSArray<ZIMMessageReceiptInfo *> *)infos{
     // The other user sets a message as read.
}


- (void)zim:(ZIM *)zim conversationMessageReceiptChanged:(NSArray<ZIMMessageReceiptInfo *> *)infos{
    // The other user sets all messages in a conversation as read.
}



NSString *conversationID = @"xxx" ; // The conversation ID.

// User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

ZIMTextMessage *message = [[ZIMTextMessage alloc] init];
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc]init];
sendConfig.hasReceipt = true;    // Set that the messages require a reading receipt.
[self.zim sendMessage:cmdMsg toUserID:toUserID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // Developers can listen for whether a message is sent successfully through this callback.
    if (errorInfo.code == 0) {
        // This indicates that the message is sent successfully. receiptStatus of the message is set to PROCESSING. The service layer can display the logic that a message is unread based on this flag.
    }
}];


// User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// Set a message as read
NSMutableArray<ZIMMessage *> *messageList = [[NSMutableArray alloc] init];

[[ZIM getInstance] sendMessageReceiptsRead:messageList conversationID:@"conversationID" conversationType:conversationType callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, NSArray<NSNumber *> * _Nonnull errorMessageIDs, ZIMError * _Nonnull errorInfo) {
     // Callback for setting a message as read.
}];
// Set a conversation as read
[[ZIM getInstance] sendConversationMessageReceiptRead:@"conversationID" conversationType:conversationType callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, ZIMError * _Nonnull errorInfo) {
    // Callback for setting all messages in a conversation as read.
}];

// (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.
NSMutableArray<ZIMMessage *> *messageList = [[NSMutableArray alloc] init];
[[ZIM getInstance] queryMessageReceiptsInfoByMessageList:messageList conversationID:conversationID conversationType:conversationType callback:^(NSArray<ZIMMessageReceiptInfo *> * _Nonnull infos, NSArray<NSNumber *> * _Nonnull errorMessageIDs, ZIMError * _Nonnull errorInfo) {
     // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
}];


// (Optional) Query the list of members who have or have not read a group message.

// The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig *config =  [[ZIMGroupMessageReceiptMemberQueryConfig alloc]init];
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
[[ZIM getInstance] queryGroupMessageReceiptReadMemberListByMessage:message groupID:groupID config:config callback:^(NSString * _Nonnull groupID, NSArray<ZIMGroupMemberInfo *> * _Nonnull userList, unsigned int nextFlag, ZIMError * _Nonnull errorInfo)    {
    // The corresponding member list is queried.
}];


// The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.
[[ZIM getInstance] queryGroupMessageReceiptUnreadMemberListByMessage:message groupID:groupID config:config callback:^(NSString * _Nonnull groupID, NSArray<ZIMGroupMemberInfo *> * _Nonnull userList, unsigned int nextFlag, ZIMError * _Nonnull errorInfo) {
    // The corresponding member list is queried.
}];
```
:::
:::if{props.platform="window"}
```cpp
// User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

zim::ZIMMessageSendConfig sendConfig;
zim::ZIMPushConfig pushConfig;

pushConfig.content = "win_push_content";
pushConfig.payload = "win_push_extended_data";
pushConfig.title = "win_push_title";

sendConfig.priority = zim::ZIM_MESSAGE_PRIORITY_MEDIUM;
sendConfig.pushConfig = &pushConfig;
sendConfig.hasReceipt = true; // Set that the messages require a reading receipt.

auto smessage = std::make_shared<zim::ZIMTextMessage>("test message");

auto notification = std::make_shared<zim::ZIMMessageSendNotification>(
    [=](const std::shared_ptr<zim::ZIMMessage> &message) { 
        
       //  Notification for message being stored in the database
    });

zim_->sendMessage(
    std::static_pointer_cast<zim::ZIMMessage>(smessage), userID,
    zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER, sendConfig, notification,
    [=](const std::shared_ptr<zim::ZIMMessage> &cb_message, const zim::ZIMError &errorInfo) {
        if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
            // This indicates that the message has been successfully sent. The receiptStatus of the message will be PROCESSING, and the business layer can implement logic to display the unread receipt.
        }
    });


// User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// Set a message as read

std::vector<std::shared_ptr<zim::ZIMMessage>> messages;
messages.emplace_back(message);

zim_->sendMessageReceiptsRead(
    messages, conversationID, zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER,
    [=](const std::string &conversationID, zim::ZIMConversationType conversationType,
        const std::vector<long long> &errorMessageIDs,
        const zim::ZIMError &errorInfo) { 
        // Callback for setting a message as read.
    });

// Set a conversation as read

zim_->sendConversationMessageReceiptRead(
    conversationID, zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER,
    [=](const std::string &conversationID, zim::ZIMConversationType conversationType,
        const zim::ZIMError &errorInfo) { 
            // Callback for conversation read receipt. Developers can use this callback to set all messages sent by the other party in this conversation as read.
    });

// (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.

std::vector<std::shared_ptr<zim::ZIMMessage>> messages;
messages.emplace_back(message);
zim_->queryMessageReceiptsInfo(
    messages, conversationID, zim::ZIMConversationType::ZIM_CONVERSATION_TYPE_PEER,
    [=](const std::vector<zim::ZIMMessageReceiptInfo> &infos,
        std::vector<long long> errorMessageIDs, const zim::ZIMError &errorInfo) {});


// (Optional) Query the list of members who have or have not read a group message.

// Read user list
zim::ZIMGroupMessageReceiptMemberQueryConfig readMemberQueryConfig;
readMemberQueryConfig.count = 10;    // Number of users to query.
readMemberQueryConfig.nextFlag = 0;    // Query flag, fill in 0 initially, and fill in the flag returned from the callback later.

zim_->queryGroupMessageReceiptReadMemberList(
    message, "group_id", readMemberQueryConfig,
    [=](const std::string &groupID, const std::vector<zim::ZIMGroupMemberInfo> &userList,
        unsigned int nextFlag, const zim::ZIMError &errorInfo) {
                if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
                   // Query the corresponding member list
                }
        });

// Unread user list
zim::ZIMGroupMessageReceiptMemberQueryConfig unreadMemberQueryConfig;
unreadMemberQueryConfig.count = 10;    // Number of users to query.
unreadMemberQueryConfig.nextFlag = 0;    // Query flag, fill in 0 initially, and fill in the flag returned from the callback later.

zim_->queryGroupMessageReceiptUnreadMemberList(
    message, "group_id", unreadMemberQueryConfig,
    [=](const std::string &groupID, const std::vector<zim::ZIMGroupMemberInfo> &userList,
        unsigned int nextFlag, const zim::ZIMError &errorInfo) {
                if (errorInfo.code == zim::ZIMErrorCode::ZIM_ERROR_CODE_SUCCESS) {
                   // Query the corresponding member list
                }
        });
```
:::

:::if{props.platform="Flutter"}
```dart
ZIMEventHandler.onMessageReceiptChanged = (zim, infos) {
// The other party has set the message read receipt
= };
    
ZIMEventHandler.onConversationMessageReceiptChanged = (zim, infos) {
        // The other party has set the conversation read receipt
};

// User A sends a message that requires a reading receipt. A text one-to-one message is used as an example.

String conversationID = "xxx" ; // The conversation ID

ZIMTextMessage message = ZIMTextMessage(message: "test");
ZIMMessageSendConfig sendConfig = ZIMMessageSendConfig();
sendConfig.hasReceipt = true; 
ZIM
    .getInstance()!
    .sendMessage(
        message, conversationID, ZIMConversationType.peer, sendConfig)
    .then((result) {
        // This indicates that the message has been successfully sent. The receiptStatus of the message will be PROCESSING, and the business layer can implement logic to display the unread receipt.
    })
    .catchError((onError) {

    });

// User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// Set a message as read

List<ZIMMessage> messages = [];
ZIM
    .getInstance()!
    .sendMessageReceiptsRead(
        messages, conversationID, ZIMConversationType.peer)
    .then((result) {
    // Callback for setting a message as read.
    })
    .catchError((onError) {

    });

// Set a conversation as read

ZIM
    .getInstance()!
    .sendConversationMessageReceiptRead(
        conversationID, ZIMConversationType.peer)
    .then((value) {
    // A conversation is read. Developers can listen for this callback to set all messages sent by the sender in this conversation as read.
    })
    .catchError((onError) {

    });

// (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.


List<ZIMMessage> messages = [];
ZIM
    .getInstance()!
    .queryMessageReceiptsInfo(
        messages, conversationID, ZIMConversationType.peer)
    .then((value) {
    // The status and quantity of this batch of messages are queried, and the corresponding message ID and count are obtained by traversing the information.
    })
    .catchError((onError) {});

// (Optional) Query the list of members who have or have not read a group message.

// The list of members who have read a group message
ZIMGroupMessageReceiptMemberQueryConfig config =
    ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.

ZIM
    .getInstance()!
    .queryGroupMessageReceiptReadMemberList(message, groupID, config)
    .then((result) {
        //  The corresponding member list is queried.
    })
    .catchError((onError) {

    });

// The list of members who have not read a group message
ZIMGroupMessageReceiptMemberQueryConfig config = ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in the callback.
config.count = 10;    // The user quantity to be queried.

ZIM
    .getInstance()!
    .queryGroupMessageReceiptUnreadMemberList(message, groupID, config)
    .then((result) {
        // The corresponding member list is queried.
    })
    .catchError((onError) {

    });
```
:::

:::if{props.platform="U3d"}
```c#
ZIM.GetInstance().onMessageReceiptChanged = (ZIM zim, List<ZIMMessageReceiptInfo> infos) =>
{
    // Message receipt status changed
};

ZIM.GetInstance().onConversationMessageReceiptChanged = (ZIM zim, List<ZIMMessageReceiptInfo> infos) =>
{
    // Conversation message receipt status changed
};

// User A sends a message with receipt, taking a peer-to-peer text message as an example

string conversationID = "xxx"; // Conversation ID

ZIMTextMessage message = new ZIMTextMessage("test");
ZIMMessageSendConfig sendConfig = new ZIMMessageSendConfig();
sendConfig.hasReceipt = true;    // Set the message with receipt
ZIMMessageSendNotification notification = new ZIMMessageSendNotification();
ZIM.GetInstance().SendMessage(message, "conversationID", ZIMConversationType.Peer, sendConfig, notification,
    (ZIMMessage message, ZIMError errorInfo) => { });

// User B receives the receipt and marks it as read, choose one of the following interfaces

// Message read

List<ZIMMessage> messages = new List<ZIMMessage>();
messages.Add(message);
ZIM.GetInstance().SendMessageReceiptsRead(messages, "conversationID", ZIMConversationType.Peer, (string conversationID, ZIMConversationType conversationType,
                   List<long> errorMessageIDs, ZIMError errorInfo) =>
{
    // Callback for sending message read
});

// Conversation read

ZIM.GetInstance().SendConversationMessageReceiptRead("conversationID", ZIMConversationType.Peer, (string conversationID, ZIMConversationType conversationType,
                           ZIMError errorInfo) =>
{
    // Callback for sending conversation message read
});

// (Optional) Query the receipt status, unread user count, and read user count for a batch of messages

List<ZIMMessage> queryMessages = new List<ZIMMessage>();
queryMessages.Add(message);
ZIM.GetInstance().QueryMessageReceiptsInfo(queryMessages, "conversationID", ZIMConversationType.Peer, (List<ZIMMessageReceiptInfo> infos, List<long> errorMessageIDs,
                           ZIMError errorInfo) =>
{ });

// (Optional) Query the list of read group members and unread group members for a specific group message

// List of read users
ZIMGroupMessageReceiptMemberQueryConfig config = new ZIMGroupMessageReceiptMemberQueryConfig();
config.nextFlag = 0;    // The flag for querying, fill in 0 initially, and then fill in the flag returned from the callback.
config.count = 10;    // The number of users to query.

ZIM.GetInstance().QueryGroupMessageReceiptReadMemberList(message, "groupID", config, (string groupID, List<ZIMGroupMemberInfo> userList,
                           uint nextFlag, ZIMError errorInfo) =>
{ });

// 6.2 List of unread users
ZIMGroupMessageReceiptMemberQueryConfig groupMessageReceiptMemberQueryConfig = new ZIMGroupMessageReceiptMemberQueryConfig();
groupMessageReceiptMemberQueryConfig.nextFlag = 0;    // The flag for querying, fill in 0 initially, and then fill in the flag returned from the callback.
groupMessageReceiptMemberQueryConfig.count = 10;    // The number of users to query.

ZIM.GetInstance().QueryGroupMessageReceiptUnreadMemberList(message, "groupID", groupMessageReceiptMemberQueryConfig, (string groupID, List<ZIMGroupMemberInfo> userList,
                           uint nextFlag, ZIMError errorInfo) => { });
```

:::

:::if{props.platform="Web"}
```javascript
// 1. Register a callback.

// The other user sets a message as read.
zim.on('messageReceiptChanged', function (zim, { infos }) {
    console.log('messageReceiptChanged', infos);
});
// The other user sets all messages in a conversation as read.
zim.on('conversationMessageReceiptChanged', function (zim, { infos }) {
    console.log('conversationMessageReceiptChanged', infos);
});

var userID_A = "xxxx" ;    // The ID of user A.
var userID_B = "xxxx" ;    // The ID of user B.

// 2. User A sends a message that requires a reading receipt to user B. A text one-to-one message is used as an example.

var messageObj = { type: 1, message: 'text receipt message' }
var config = {
    priority: 1,    // Message priority. Valid values: 1: Low (default), 2: Medium, 3: High
    hasReceipt: true    // Set that the messages require a reading receipt.
}
var notification = {
    onMessageAttached: function(message) {
        // todo: Loading
    }
}

zim.sendMessage(messageObj, userID_B, 0, config, notification)
    .then(function ({ message }) {
        // Sent successfully.
    })
    .catch(function (err) {
        // Sending failed.
    });

// 3. User B receives the message that requires a reading receipt and sets the message as read by calling any of the following APIs.

// 3.1 Set a message as read
var messages = [];    // Queried from queryHistoryMessage or received from peerMessageReceived
zim.sendMessageReceiptsRead(messages, userID_A, 0)    
    .then(function ({ conversationID, conversationType, errorMessageIDs }) {
        // The operation is successful. Messages that failed to be set as read are returned through errorMessageIDs.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 3.2 Set a conversation as read
zim.sendConversationMessageReceiptRead(userID_A, 0)
    .then(function ({ conversationID, conversationType }) {
        // The operation is successful. User B can set all messages sent from user A in this conversation as read.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 4. (Optional) Batch query the message receipt status, number of users who have read the message, and number of users who have not read the message.

var messages = []; // Queried from queryHistoryMessage
zim.queryMessageReceiptsInfo(messages, userID_B, 0)    
    .then(function ({ infos, errorMessageIDs }) {
        // The operation is successful. Messages that failed to be queried are returned through errorMessageIDs.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 5. (Optional) Query the list of members who have or have not read a group message.

var groupMsgObj = {}    // Queried from queryHistoryMessage
var queryConfig = {
    count: 10,    // The user quantity to be queried.
    nextFlag: 0    // The query flag. It is set to 0 in the first query. In subsequent queries, it is set to the flag returned in Promise.
}

// 5.1 The list of members who have read a group message
zim.queryGroupMessageReceiptReadMemberList(groupMsgObj, groupMsgObj.conversationID, queryConfig)
    .then(function ({ nextFlag, userList, groupID }) {
        // The operation is successful.
    })
    .catch(function (err) {
        // The operation fails.
    });

// 5.2 The list of members who have not read a group message
zim.queryGroupMessageReceiptUnreadMemberList(groupMsgObj, groupMsgObj.conversationID, queryConfig)
    .then(function ({ nextFlag, userList, groupID }) {
        // The operation is successful.
    })
    .catch(function (err) {
        // The operation fails.
    });
```
:::