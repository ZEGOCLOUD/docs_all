# Display User and Agent Instance Status

During real-time voice calls with AI agents, you may need to display the AI agent instance status and user speaking status changes in real-time on the client interface to enhance user experience. You can obtain these statuses by listening to corresponding client or server callback events.

Status messages include the following types:

- AI agent instance creation and destruction status: AI agent instance created successfully, AI agent instance destroyed successfully.
- AI agent instance status events: Idle, Listening, Thinking, Speaking.
- User speaking status events: Start speaking, Stop speaking.

## Quick Implementation

To display user and AI agent instance status, there are two methods:
1. Listen to ZEGOCLOUD Express SDK experimental API callbacks on the client.
2. Listen to AI agent instance status and user speaking status events through server callbacks, then send custom messages to the client through your own signaling channel (such as WebSocket, etc.).

### Prerequisites

1. AI Agent service is enabled
2. ZEGOCLOUD Express SDK is initialized and joined the [RTC room](/glossary/term-explanation#rtc-room#rtc-room)
3. The server has called the [Create Agent Instance](/aiagent-server/api-reference/agent-instance-management/create-agent-instance) API

### Listen to ZEGOCLOUD Express SDK Experimental API Callbacks <a id="listen-zego-express-sdk-experimental-api-callback" />

<Note title="Note">This method is simpler and is recommended for displaying user and AI agent instance status</Note>

By listening to ZEGOCLOUD Express SDK experimental API callbacks (onRecvExperimentalAPI or recvExperimentalAPI) on the client SDK, you can handle corresponding status events based on message type. Below are example codes for each platform:

<Tabs>

<Tab title="iOS">
The client can listen to the `onRecvExperimentalAPI` callback by implementing the ZegoEventHandler protocol to obtain custom room messages with `method` as `liveroom.room.on_recive_room_channel_message`. Detailed field descriptions can be referred to [AI Agent Instance SDK Callbacks](/aiagent-ios/client-sdk/ai-related-callback) . Below is an example of the listener callback code:
<CodeGroup>
```oc YourService.h/m
// Implement ZegoEventHandler protocol
@interface YourService () <ZegoEventHandler>
@property (nonatomic, strong) YourViewController *youViewController;
@end

@implementation YourService

// WARNING!!!: The data received through custom room messages may be out of order, and sorting needs to be performed based on the SeqId field.
// Handle messages received from express onRecvExperimentalAPI
- (void)onRecvExperimentalAPI:(NSString *)content {
    // Forward to view to parse message content
    // !mark
    [self.youViewController handleExpressExperimentalAPIContent:content];
}

@end // YourService implementation
```

```oc YourViewController.h/m
// Implement ZegoEventHandler protocol in the header file
@interface YourViewController ()

@end

@implementation YourViewController

// Parse custom signaling messages
- (void)handleExpressExperimentalAPIContent:(NSString *)content {
    // Parse JSON content
    NSError *error;
    NSData *jsonData = [content dataUsingEncoding:NSUTF8StringEncoding];
    NSDictionary *contentDict = [NSJSONSerialization JSONObjectWithData:jsonData
                                                        options:NSJSONReadingMutableContainers
                                                          error:&error];
    if (error || !contentDict) {
        NSLog(@"JSON parsing failed: %@", error);
        return;
    }
    // Check if it is a room message
    NSString *method = contentDict[@"method"];
    if (![method isEqualToString:@"liveroom.room.on_recive_room_channel_message"]) {
        return;
    }
    // Get message parameters
    NSDictionary *params = contentDict[@"params"];
    if (!params) {
        return;
    }
    NSString *msgContent = params[@"msg_content"];
    NSString *sendIdName = params[@"send_idname"];
    NSString *sendNickname = params[@"send_nickname"];
    NSString *roomId = params[@"roomid"];
    if (!msgContent || !sendIdName || !roomId) {
         NSLog(@"parseExperimentalAPIContent incomplete parameters: msgContent=%@, sendIdName=%@, roomId=%@",
                msgContent, sendIdName, roomId);
        return;
    }

    // Typical JSON content examples:
    // User speaking status (Cmd=1): "{\"Timestamp\":1765510379,\"TimestampMs\":1765510379113,\"SeqId\":278800715,\"Round\":510359002,\"Cmd\":1,\"Legacy\":false,\"Data\":{\"SpeakStatus\":1,\"UserId\":\"38475\"}}"
    // Agent instance status (Cmd=6): "{\"Timestamp\":1765510398,\"TimestampMs\":1765510398029,\"SeqId\":278800725,\"Round\":0,\"Cmd\":6,\"Legacy\":false,\"Data\":{\"OldStatus\":3,\"Status\":0,\"Reason\":\"tts_all_played\"}}"
    // Parse message content
    [self handleMessageContent:msgContent userID:sendIdName userName:sendNickname ?: @""];
}

// Handle message content
- (void)handleMessageContent:(NSString *)command userID:(NSString *)userID userName:(NSString *)userName{
    NSDictionary* msgDict = [self dictFromJson:command];
    if (!msgDict) {
        return;
    }

    // Parse basic information
    int cmd = [msgDict[@"Cmd"] intValue];
    int64_t seqId = [msgDict[@"SeqId"] longLongValue];
    int64_t round = [msgDict[@"Round"] longLongValue];
    int64_t timestamp = [msgDict[@"Timestamp"] longLongValue];
    NSDictionary *data = msgDict[@"Data"];

    // Handle messages based on command type
    switch (cmd) {
        // !mark
        case 1: // User speaking status
            [self handleUserSpeakStatus:data seqId:seqId round:round timestamp:timestamp];
            break;
        // !mark
        case 6: // Agent instance status
            [self handleAgentInstanceStatus:data seqId:seqId round:round timestamp:timestamp];
            break;
    }
}

@end // YourViewController implementation
```
</CodeGroup>

</Tab>
<Tab title="Android">
The client can listen to the `onRecvExperimentalAPI` callback to obtain custom room messages with `method` as `liveroom.room.on_recive_room_channel_message`. Detailed field descriptions can be referred to [AI Agent Instance SDK Callbacks](/aiagent-android/client-sdk/ai-related-callback) . Below is an example of the listener callback code:
```java
// Typical JSON content examples:
// User speaking status (Cmd=1):
// {"method":"liveroom.room.on_recive_room_channel_message","params":{"msg_content":"{\"Timestamp\":1765510379,\"TimestampMs\":1765510379113,\"SeqId\":278800715,\"Round\":510359002,\"Cmd\":1,\"Legacy\":false,\"Data\":{\"SpeakStatus\":1,\"UserId\":\"38475\"}}","msg_type":1,"roomid":"ir_20p158E0","send_idname":"@RBT#38475_xiaozhi-sx_174722027","send_nickname":""}}
// Agent instance status (Cmd=6):
// {"method":"liveroom.room.on_recive_room_channel_message","params":{"msg_content":"{\"Timestamp\":1765510398,\"TimestampMs\":1765510398029,\"SeqId\":278800725,\"Round\":0,\"Cmd\":6,\"Legacy\":false,\"Data\":{\"OldStatus\":3,\"Status\":0,\"Reason\":\"tts_all_played\"}}","msg_type":1,"roomid":"ir_20p158E0","send_idname":"@RBT#38475_xiaozhi-sx_174722027","send_nickname":""}}
ZegoExpressEngine.getEngine().setEventHandler(new IZegoEventHandler() {
    // !mark(1:2)
    @Override
    public void onRecvExperimentalAPI(String content) {
        super.onRecvExperimentalAPI(content);
        try {
            // Step 1: Parse content into JSONObject
            JSONObject json = new JSONObject(content);

            // Step 2: Check the value of the method field
            if (json.has("method") && json.getString("method")
                .equals("liveroom.room.on_recive_room_channel_message")) {
                // Step 3: Get params and parse
                JSONObject paramsObject = json.getJSONObject("params");
                String msgContent = paramsObject.getString("msg_content");

                // JSON string example see above
                // Parse JSON string into AIAgentCustomMessage object
                AIAgentCustomMessage chatMessage = gson.fromJson(msgContent, AIAgentCustomMessage.class);
                // !mark
                if (chatMessage.cmd == 1) { // User speaking status
                    handleUserSpeakStatus(chatMessage);
                    // !mark
                } else if (chatMessage.cmd == 6) { // Agent instance status
                    handleAgentStatus(chatMessage);
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
});

/**
 * Agent instance status and user speaking status message structure
 */
public static class AIAgentCustomMessage {

    @SerializedName(value = "Timestamp", alternate = "timestamp")
    public long timestamp;
    @SerializedName(value = "TimestampMs", alternate = "timestamp_ms")
    public long timestampMs;
    @SerializedName(value = "SeqId", alternate = "seq_id")
    public long seqId;
    @SerializedName(value = "Round", alternate = "round")
    public long round;
    @SerializedName(value = "Cmd", alternate = "cmd")
    public int cmd;
    @SerializedName(value = "Legacy", alternate = "legacy")
    public boolean legacy;
    @SerializedName(value = "Data", alternate = "data")
    public Data data;

    public static class Data {

        // User speaking status message (Cmd=1)
        @SerializedName(value = "SpeakStatus", alternate = "speak_status")
        public int speakStatus; // 1: Speaking started, 2: Speaking ended
        @SerializedName(value = "UserId", alternate = "user_id")
        public String userId;

        // Agent instance status message (Cmd=6)
        @SerializedName(value = "OldStatus", alternate = "old_status")
        public Integer oldStatus; // 0: Idle 1: Listening 2: Thinking 3: Speaking
        @SerializedName(value = "Status", alternate = "status")
        public Integer status; // 0: Idle 1: Listening 2: Thinking 3: Speaking
        @SerializedName(value = "Reason", alternate = "reason")
        public String reason;
    }
}
```
</Tab>
<Tab title="Flutter">
The client can listen to the `onRecvExperimentalAPI` callback to obtain custom room messages with `method` as `liveroom.room.on_recive_room_channel_message`. Detailed field descriptions can be referred to [AI Agent Instance SDK Callbacks](/aiagent-flutter/client-sdk/ai-related-callback) . Below is an example of the listener callback code:
```dart
import 'dart:convert';

import 'package:flutter/cupertino.dart';
import 'package:zego_express_engine/zego_express_engine.dart';

class YourPage extends StatefulWidget {
  const YourPage({super.key});

  @override
  State<YourPage> createState() => _YourPageState();
}

class _YourPageState extends State<YourPage> {
  @override
  void initState() {
    super.initState();

    // !mark
    ZegoExpressEngine.onRecvExperimentalAPI = onRecvExperimentalAPI;
  }

  @override
  void dispose() {
    super.dispose();

    ZegoExpressEngine.onRecvExperimentalAPI = null;
  }

  @override
  Widget build(BuildContext context) {
    return YourMessageView();
  }

  /// User speaking status (Cmd=1):
  /// {"Timestamp":1765510379,"TimestampMs":1765510379113,"SeqId":278800715,"Round":510359002,"Cmd":1,"Legacy":false,"Data":{"SpeakStatus":1,"UserId":"38475"}}
  /// Agent instance status (Cmd=6):
  /// {"Timestamp":1765510398,"TimestampMs":1765510398029,"SeqId":278800725,"Round":0,"Cmd":6,"Legacy":false,"Data":{"OldStatus":3,"Status":0,"Reason":"tts_all_played"}}
  void onRecvExperimentalAPI(String content) {
    try {
      /// Check if it is a room message
      final contentMap = jsonDecode(content);
      if (contentMap['method'] !=
          'liveroom.room.on_recive_room_channel_message') {
        return;
      }

      final params = contentMap['params'];
      if (params == null) {
        return;
      }

      final msgContent = params['msg_content'];
      if (msgContent == null) {
        return;
      }

      handleMessageContent(msgContent);
    } catch (e) {}
  }

  /// Handle message content
  void handleMessageContent(String msgContent) {
    final Map<String, dynamic> json = jsonDecode(msgContent);

    /// Parse basic information
    final int timestamp = json['Timestamp'] ?? 0;
    final int seqId = json['SeqId'] ?? 0;
    final int round = json['Round'] ?? 0;
    final int cmdType = json['Cmd'] ?? 0;
    final Map<String, dynamic> data =
        json['Data'] != null ? Map<String, dynamic>.from(json['Data']) : {};

    // Handle messages based on command type
    switch (cmdType) {
      /// !mark
      case 1:
        /// User speaking status
        handleUserSpeakStatus(data, seqId, round, timestamp);
        break;
      /// !mark
      case 6:
        /// Agent instance status
        handleAgentInstanceStatus(data, seqId, round, timestamp);
        break;
    }
  }
}
```
</Tab>
<Tab title="Web/MiniProgram">
The client can listen to the `recvExperimentalAPI` callback to obtain custom room messages with `method` as `onRecvRoomChannelMessage`. Detailed field descriptions can be referred to [AI Agent Instance SDK Callbacks](/aiagent-web/client-sdk/ai-related-callback) . Below is an example of the listener callback code:

```javascript {2,4,15}
// User speaking status (Cmd=1):
// {"Timestamp":1765510379,"TimestampMs":1765510379113,"SeqId":278800715,"Round":510359002,"Cmd":1,"Legacy":false,"Data":{"SpeakStatus":1,"UserId":"38475"}}
// Agent instance status (Cmd=6):
// {"Timestamp":1765510398,"TimestampMs":1765510398029,"SeqId":278800725,"Round":0,"Cmd":6,"Legacy":false,"Data":{"OldStatus":3,"Status":0,"Reason":"tts_all_played"}}
zg.on("recvExperimentalAPI", (result) => {
  const { method, content } = result;
  // !mark
  if (method === "onRecvRoomChannelMessage") {
    try {
      // Parse message
      const recvMsg = JSON.parse(content.msgContent);
      const { Cmd, SeqId, Data, Round } = recvMsg;
      // !mark
      if (Cmd === 1) {
        // User speaking status message handling, e.g. Data.SpeakStatus 1=start 2=end
        handleUserSpeakStatus(Data, SeqId, Round);
        // !mark
      } else if (Cmd === 6) {
        // Agent instance status message handling, e.g. Data.Status 0=idle 1=listening 2=thinking 3=speaking
        handleAgentStatus(Data, SeqId, Round);
      }
    } catch (error) {
      console.error("Failed to parse message:", error);
    }
  }
});
// Enable onRecvRoomChannelMessage experimental API
zg.callExperimentalAPI({ method: "onRecvRoomChannelMessage", params: {} });

```
</Tab>
</Tabs>


### Listen to Agent Instance Status and User Speaking Status Events Through Server Callbacks, Then Send Custom Messages to Clients Through Your Own Signaling Channel


If your application already has its own signaling channel, such as WebSocket or instant messaging system, you can:

- After receiving status event callbacks on the server, forward the status information to relevant clients through your signaling channel.
- Agree on the message format with the client, and the client updates the UI interface based on the received status information (such as displaying speaking indicators, animations, etc.).

The advantage of this method is that you can fully control the message format and transmission logic, which is suitable for applications with mature signaling systems.

#### Listen for Server Callbacks

Please refer to the [Receiving Callback](./../callbacks/receiving-callback.mdx) documentation to develop callbacks for receiving AI Agent event notifications, and contact ZEGOCLOUD technical support to configure the callback address.
<Note title="Note">

To receive user and agent instance status callback results, when [creating an agent instance](./../api-reference/agent-instance-management/create-agent-instance.mdx), configure the corresponding [CallbackConfig.UserSpeakAction](./../api-reference/agent-instance-management/create-agent-instance.mdx#callbackconfig) and [CallbackConfig.AgentInstanceStatus](./../api-reference/agent-instance-management/create-agent-instance.mdx#callbackconfig) parameters to `1`.

</Note>

Callback content samples are as follows:

<CodeGroup>
```json title="Agent instance status callback" {5,7}
{
    "AppId": 1234567,
    "AgentInstanceId": "1912124734317838336",
    "Data": {
        "Status": "LISTENING",// IDLE: Idle LISTENING: Listening THINKING: Thinking SPEAKING: Speaking
    },
    "Event": "AgentInstanceStatus",
    "Nonce": "7450395512627324902",
    "Signature": "fd9c1ce54e85bd92f48b0a805e82a52b0c0c6445",
    "Timestamp": 1745502313000,
    "AgentUserId": "123456789",
    "RoomId": "123456789",
    "Sequence": 123456789,
}
```
```json title="User speaking status callback" {5,7}
{
    "AppId": 1234567,
    "AgentInstanceId": "1912124734317838336",
    "Data": {
        "Action": "SPEAK_BEGIN",// SPEAK_BEGIN: Start speaking SPEAK_END: Stop speaking
    },
    "Event": "UserSpeakAction",
    "Nonce": "7450395512627324902",
    "Signature": "fd9c1ce54e85bd92f48b0a805e82a52b0c0c6445",
    "Timestamp": 1745502313000,
    "AgentUserId": "123456789",
    "RoomId": "123456789",
    "Sequence": 123456789,
}
```
</CodeGroup>

{/* 暂时不再推荐使用 RTC 房间消息下发


The advantage of this approach is complete control over message format and transmission logic, making it suitable for applications with mature signaling systems.

#### Using ZEGOCLOUD RTC Room Message Channel for Custom Messages

If you don't have your own business signaling channel, you can utilize ZEGOCLOUD RTC's room messaging feature:

- Call ZEGOCLOUD RTC Server API to send custom messages after receiving status event callbacks on the server
- Agree on a message format with clients, so they can listen for custom messages via ZEGOCLOUD RTC SDK and update their UI based on status change notifications (e.g., display speaking indicators, animations)

The advantage of this approach is that no additional signaling system setup is required, as you can directly use ZEGOCLOUD's infrastructure. However, the disadvantage is that room messages are not guaranteed to be completely reliable and have sending frequency limitations, making them unsuitable for scenarios requiring high message reliability.


Implementation examples are as follows:
<Tabs>
<Tab title="Server">

Here is an example code of the server receiving AI agent and user speaking status events and sending custom messages through ZEGOCLOUD Server API [Send Custom Message](https://docs.zegocloud.com/article/9784):


```javascript {27-30,47-72}
export class AgentCallbackController {
    // Send custom command to RTC room
    private async handleSendCustomCommand(
        commonArgs: any,
        roomId: string,
        agentUserId: string,
        data: any,
    ) {
        try {
            // Build query parameters, ToUserId[] appears multiple times as an array
            const params: Record<string, any> = {
                Action: 'SendCustomCommand',
                RoomId: roomId,
                FromUserId: agentUserId,
                MessageContent: JSON.stringify(data),
                ...commonArgs
            };
            // Append ToUserId[]
            const searchParams = new URLSearchParams();
            Object.entries(params).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach(v => searchParams.append(key, v));
                } else {
                    searchParams.append(key, value);
                }
            });
            // Build complete URL
            const url = `https://rtc-api.zego.im/?${searchParams.toString()}`;
            // Send GET request directly to send custom message
            const res = await rtcRequest<any>({ method: 'GET', url });

            if (res.Code !== 0) logger.error(`sendCustomCommand errorCode: ${res.Code}, errorMessage: ${res.Message}`);
        } catch (err) {
            const errMsg = err instanceof Error ? err.message : String(err);
            logger.error('[AgentCallbackController] handleSendCustomCommand error:' + errMsg);
        }
    }
    // Receive AI agent instance status and user speaking status change callbacks
    callbackHandler = async (req: Request, res: Response) => {
        const RequestId = req.headers.RequestId as string;
        const payload = req.body as AIAgentCallbackPayload;
        const { AppId, AgentInstanceId, RoomId, AgentUserId, Event, Data } = payload;

        // For commonArgs generation, refer to https://www.zegocloud.com/docs/article/19456#3
        const commonArgs = genCommonArgs(AppId, globalConfig.appEnvSecretMap[AppId]);

        switch (Event) {
            case AgentEvent.AgentInstanceStatus: {
                const { Sequence, Status } = Data as AgentInstanceStatusPayload;
                const command = {
                    eventType: 'AgentInstanceStatus',
                    data: {
                        sequence: Sequence,
                        status: Status,
                    },
                };
                await this.handleSendCustomCommand(commonArgs, RoomId, AgentInstanceId, command);
                break;
            }
            case AgentEvent.UserSpeakAction: {
                const { UserId, Sequence, Action } = Data as UserSpeakActionPayload;
                const command = {
                    eventType: 'UserSpeakAction',
                    data: {
                        userId: UserId,
                        sequence: Sequence,
                        action: Action,
                    },
                };
                await this.handleSendCustomCommand(commonArgs, RoomId, AgentInstanceId, command);
                break;
            }
            // ... Handle other events
        }
    };
}
```

</Tab>
<Tab title="Client">

Here are example codes for receiving messages on different client platforms:

<CodeGroup>
```javascript title="Web"
// 3. Listen for custom messages via ZEGOCLOUD RTC SDK
    zg.on("IMRecvCustomCommand", (roomID: string, fromUser: ZegoUser, command: string) => {
      try {
        const message = JSON.parse(command);
        switch (message.eventType) {
          case "AgentInstanceStatus":
            // Handle agent instance status event
            // Update UI
            break;
          case "UserSpeakAction":
            // Handle user speaking status event
            // Update UI
            break;
        }
      } catch (error) {
        console.error("Failed to parse message:", error);
      }
    });
```
```objc title="iOS"
@interface YourClass () <ZegoEventHandler>

@end

@implementation YourClass

- (void)onIMRecvCustomCommand:(NSString *)command
                     fromUser:(ZegoUser *)fromUser
                       roomID:(NSString *)roomID{
    if (command == nil) {
        return;
    }

    NSDictionary* msgDict = [ZegoAIAgentUtil dictFromJson:command];
    if (!msgDict) {
        return;
    }

    NSString *eventType = msgDict[@"eventType"];
    if (eventType) {
        if ([eventType isEqualToString:@"AgentInstanceStatus"]) {
            // Handle agent instance status event
            // Update UI
        } else if ([eventType isEqualToString:@"UserSpeakAction"]) {
            // Handle user speaking status event
            // Update UI
        }
    }
}
@end
```
```java title="Android"
// Listen for custom messages via ZEGOCLOUD RTC SDK
ZegoExpressEngine.getEngine().setEventHandler(new IZegoEventHandler() {
    @Override
    public void onIMRecvCustomCommand(String roomID, ZegoUser fromUser, String command) {
        super.onIMRecvCustomCommand(roomID, fromUser, command);
        try {
            // Step 1: Parse content to JSONObject
            JSONObject json = new JSONObject(command);
            if (json.has("eventType")) {
                String eventType = json.getString("eventType");
                if ("AgentInstanceStatus".equals(eventType)) {
                    // Handle agent instance status event
                    // Update UI
                } else if ("UserSpeakAction".equals(eventType)) {
                    // Handle user speaking status event
                    // Update UI
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
});
```
</CodeGroup>

</Tab>
</Tabs>
*/}
