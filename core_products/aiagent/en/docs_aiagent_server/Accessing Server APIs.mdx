# Accessing Server APIs
---

## Request Structure


### Service Address

Developers need to specify the corresponding access address based on the geographical location of their server, and send requests to the ZEGOCLOUDserver.

<Warning title="Warning">

To ensure the quality of your business service access, please prioritize using the domain name of the geographical region where your server is located as the access address when sending requests to the ZEGOCLOUD server.
</Warning>

ZEGOCLOUD supports request access from the following geographical regions:

<table>
<tbody><tr>
<th>Geographical Region</th>
<th>Access Address</th>
</tr>
<tr>
<td>Mainland China (Shanghai)</td>
<td>`https://aigc-aiagent-api-sha.zegotech.cn`</td>
</tr>
<tr>
<td>Hong Kong, Macao, Taiwan (Hong Kong)</td>
<td>`https://aigc-aiagent-api-hkg.zegotech.cn`</td>
</tr>
<tr>
<td>Europe (Frankfurt)</td>
<td>`https://aigc-aiagent-api-fra.zegotech.cn`</td>
</tr>
<tr>
<td>Western U.S. (California)</td>
<td>`https://aigc-aiagent-api-lax.zegotech.cn`</td>
</tr>
<tr>
<td>Asia-Pacific (Mumbai)</td>
<td>`https://aigc-aiagent-api-bom.zegotech.cn`</td>
</tr>
<tr>
<td>Southeast Asia (Singapore)</td>
<td>`https://aigc-aiagent-api-sgp.zegotech.cn`</td>
</tr>
<tr>
<td>Unified Access Address (Region-agnostic)</td>
<td>`https://aigc-aiagent-api.zegotech.cn`</td>
</tr>
</tbody></table>

### Communication Protocol

For secure communications, all the Server APIs must be accessed via HTTPS requests.

### Request Methods

The  server API supports the following HTTP request methods:

- GET
- POST


<Note title="Note">

For a GET request, all request parameters (including public parameters and business-related parameters) should be placed in the Query. For a POST request, special and complex parameters can be placed in the Request Body.
</Note>

## Common Parameters

### Public Request Parameters

Public request parameters are the parameters that are required for every API request.

| Parameter         | Type     | Required | Description                                   |
|-------------------|----------|----------|----------------------------------------------|
| AppId             | Uint32   | Yes      | AppId, the unique user credential assigned by ZEGO. |
| Signature         | String   | Yes      | Signature, please refer to the signature mechanism for its generation. |
| SignatureNonce    | String   | Yes      | Random string.                                |
| SignatureVersion  | String   | Yes      | Signature version number, default value is 2.0. |
| Timestamp         | Int64    | Yes      | Unix timestamp, in seconds. A maximum error of 10 minutes is allowed. |

Request example:

<CodeGroup>
```json title="Post Request"
https://aigc-aiagent-api.zegotech.cn/?Action=xxx
&AppId=1234567890
&SignatureNonce=15215528852396
&Timestamp=1234567890
&Signature=7a2c0f11145fb760d607a07b54825013
&SignatureVersion=2.0
```

```json title="Get Request"
https://aigc-aiagent-api.zegotech.cn/?Action=xxx
&AppId=1234567890
&SignatureNonce=15215528852396
&Timestamp=1234567890
&Signature=7a2c0f11145fb760d607a07b54825013
&SignatureVersion=2.0
&<Non-public request parameters>
```
</CodeGroup>

<Note title="Note">
For ID-type parameters in non-public request parameters, including UserId, AgentId, RoomId, StreamId, etc., the following rules should be followed:
- Character restrictions for AgentId: numbers, English letters, and the following special characters: !#$%&()+-:;\<=.>?@[]^_ {}|~,
- Character restrictions for other ID-type parameters: numbers, English letters, '-', '_'.
- Maximum length:
  - AgentId: 128 bytes.
  - RoomId, StreamId: 128 bytes.
  - UserId: 32 bytes.
</Note>

### Common Return Parameters

API returns results in a unified format, with the data format being JSON. 
Every time an interface is called, whether successful or not, common parameters will be returned.

| Parameter  | Type       | Description             |
|------------|------------|-------------------------|
| Code       | Number     | Error code.            |
| Message    | String     | Explanation of the request result. |
| RequestId  | String     | Request ID.            |
| Data       | Object     | Response object. For more details, see the response parameters for each interface. |

Response Example:

```json
{
    "Code": 0,
    "Message": "Succeed",
    "RequestId": "1843985617336143872",
    "Data": null
}
```

## Signature Mechanism


To ensure the secure invocation of APIs, the ZEGOCLOUDserver will authenticate each API access request. Developers must include the signature Signature information in the request when calling an API.

<Warning title="Note">
    
A new signature must be generated for each interface call.  
</Warning>

### Get the AppId and Server Secret Key

To generate a request signature, you will need to use the AppId and ServerSecret assigned to your project by ZEGOCLOUD. The AppId is used as the identifier of the request sender, and ServerSecret is the secret key to generate the signature string on the request sender side and verify the signature on the ZEGOCLOUD server. To ensure system security, please keep this information strictly confidential.

You can find the AppId and ServerSecret of your project in the [ZEGOCLOUD Admin Console](https://console.zego.im/).


### Signature Generation

#### Signature Parameter Description

| Parameter       | Meaning                                                         |
|-----------------|-----------------------------------------------------------------|
| AppId           | Application ID.                                                 |
| SignatureNonce  | Random string. The SignatureNonce in the public parameters, you can refer to the signature example below for the generation algorithm. |
| ServerSecret    | Application secret key.                                         |
| Timestamp       | Current Unix timestamp in seconds. You can refer to the signature example below for the generation algorithm; a maximum deviation of 10 minutes is allowed. |

<Note title="Note">

The values of the SignatureNonce and Timestamp parameters used for calculating the signature must be consistent with the values of the SignatureNonce and Timestamp parameters in the public parameters.
</Note>

#### Signature Generation Algorithm

Signature = md5(AppId + SignatureNonce + ServerSecret + Timestamp)

#### Signature String Format

The signature uses hex encoding (lowercase), with a length of 32 characters.

### Signature Example

ZEGOCLOUDprovides signature example codes in various programming languages, and developers can refer to them according to their actual situations.

<CodeGroup>
```go title="Go"
import (
   "crypto/md5"
   "crypto/rand"
   "encoding/hex"
   "fmt"
   "log"
   "time"
)
// Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
func GenerateSignature(appId uint32, signatureNonce string, serverSecret string, timestamp int64) (Signature string){
   data := fmt.Sprintf("%d%s%s%d", appId, signatureNonce, serverSecret, timestamp)
   h := md5.New()
   h.Write([]byte(data))
   return hex.EncodeToString(h.Sum(nil))
}
func main() {
   /* Generate a 16-character random hexadecimal string (16 bits) */
   nonceByte := make([]byte, 8)
   rand.Read(nonceByte)
   signatureNonce := hex.EncodeToString(nonceByte)
   log.Printf(signatureNonce)
   appId := 12345       // Use your appId and serverSecret
   serverSecret := "9193cc662a4c0ec135ec71fb57194b38"
   timestamp := time.Now().Unix()
   /* appId:12345
      signatureNonce:4fd24687296dd9f3
      serverSecret:9193cc662a4c0ec135ec71fb57194b38
      timestamp:1615186943      2021/03/08 15:02:23
      signature:43e5cfcca828314675f91b001390566a
    */
   log.Printf("signature:%v", GenerateSignature(uint32(appId), signatureNonce, serverSecret, timestamp))
}
```

```python title="Python"
# -*- coding: UTF-8 -*-
import secrets
import string
import hashlib
import time
#Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
def GenerateSignature(appId, signatureNonce, serverSecret, timestamp):
    str1 = str(appId) + signatureNonce + serverSecret + str(timestamp)
    hash = hashlib.md5()
    hash.update(str1.encode("utf8"))
    signature = hash.hexdigest()
    return signature

def main():
    # Generate a 16-character hexadecimal random string (16 bits)
    signatureNonce = secrets.token_hex(8)

    # Use your appId and serverSecret
    appId = 12345
    serverSecret = "9193cc662a4c0ec135ec71fb57194b38"
    # Get a 10-digit Unix timestamp
    timestamp = int(time.time())
    print(GenerateSignature(appId,signatureNonce,serverSecret,timestamp))

if __name__ == '__main__':
    main()
```

```java title="Java"
import java.security.MessageDigest;
import java.security.SecureRandom;

public class Md5 {
    /**
     * Convert byte array to hexadecimal
     * @param bytes The byte array to be converted
     * @return The converted Hex string
     */
    public static String bytesToHex(byte[] bytes) {
        StringBuffer md5str = new StringBuffer();
        // Convert each byte in the array to a hexadecimal and concatenate into an MD5 string
        int digital;
        for (int i = 0; i < bytes.length; i++) {
            digital = bytes[i];
            if (digital < 0) {
                digital += 256;
            }
            if (digital < 16) {
                md5str.append("0");
            }
            md5str.append(Integer.toHexString(digital));
        }
        return md5str.toString();
    }

    // Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
    public static String GenerateSignature(long appId, String signatureNonce, String serverSecret, long timestamp){
        String str = String.valueOf(appId) + signatureNonce + serverSecret + String.valueOf(timestamp);
        String signature = "";
        try{
            // Create an object that provides a message digest algorithm, initialized as an MD5 algorithm object
            MessageDigest md = MessageDigest.getInstance("MD5");
            // Compute and obtain the byte array
            byte[] bytes = md.digest(str.getBytes("utf-8"));
            // Convert each byte in the array to hexadecimal and concatenate into an MD5 string
            signature = bytesToHex(bytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return signature;
    }

    public static void main(String[] args){
        // Generate a 16-character random hexadecimal string (16 characters)
        byte[] bytes = new byte[8];

        // Use SecureRandom to get a high-strength secure random number generator
        SecureRandom sr = new SecureRandom();

        sr.nextBytes(bytes);
        String signatureNonce = bytesToHex(bytes);
        long appId = 12345L;       // Use your appId and serverSecret, add uppercase L or lowercase l after numbers to indicate long type
        String serverSecret = "9193cc662a4c0ec135ec71fb57194b38";
        long timestamp = System.currentTimeMillis() / 1000L;
        System.out.println(GenerateSignature(appId,signatureNonce,serverSecret,timestamp));
    }
}
```

```php title="PHP"
<?php
function GenerateSignature($appId, $signatureNonce, $serverSecret, $timestamp)
{
    $str = $appId.$signatureNonce.$serverSecret.$timestamp;
    $signature = md5($str);
    return $signature;
}

// Generate a 16-bit hexadecimal random string
$signatureNonce = bin2hex(random_bytes(8));
// Use your appId and serverSecret
$appId = 12345;
$serverSecret = "9193cc662a4c0ec135ec71fb57194b38";
$timestamp = time();
$signature = GenerateSignature($appId, $signatureNonce, $serverSecret, $timestamp);
echo $signature;
?>
```
```javascript title="Node.js"
const crypto = require('crypto'); 
//Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
function GenerateUASignature(appId, signatureNonce, serverSecret, timeStamp){
    const hash = crypto.createHash('md5'); // Specifies the use of the MD5 algorithm in hash functions
    var str = appId + signatureNonce + serverSecret + timeStamp;
    hash.update(str);
    // hash.digest('hex') indicates that the output format is hexadecimal
    return hash.digest('hex');
}

var signatureNonce = crypto.randomBytes(8).toString('hex');
// Use your appId and serverSecret
var appId = 12345;
var serverSecret = "9193cc662a4c0ec135ec71fb57194b38";
var timeStamp = Math.round(Date.now()/1000);
console.log(GenerateUASignature(appId, signatureNonce, serverSecret, timeStamp));
```

</CodeGroup>

### Signature Failure

The following return codes for signature failure exist. Please handle them according to the actual situation.

| Return Code | Description |
| --- | --- |
| 100000004 | Signature expired. |
| 100000005 | Signature error. |