# 展示用户和智能体实例状态

在与智能体进行实时语音通话时，可能需要在客户端界面上实时展示智能体实例状态和用户说话的状态变化以提升用户体验。您可以通过监听服务端或客户端回调的相应事件来获取这些状态。

状态消息包括以下类型：

- 智能体实例创建及销毁状态：智能体实例创建成功、智能体实例销毁成功。
- 智能体实例状态事件：空闲中、倾听中、思考中、说话中。
- 用户说话状态事件：开始说话，说话结束。

## 快速实现

要实现展示用户和智能体实例状态，有两种方式：
1. 在客户端监听 ZEGO Express SDK 试验性 API 回调。
2. 通过服务端回调监听智能体实例状态和用户说话状态事件，然后通过自有信令通道（如 WebSocket 等）发送自定义消息到客户端。

### 前提条件

1. 开通AI Agent服务
2. ZEGO Express SDK 初始化完成并加入 [RTC 房间](/glossary/term-explanation#rtc-room#rtc-room)
3. 服务端已经调用[创建智能体实例](/aiagent-server/api-reference/agent-instance-management/create-agent-instance) API

### 在客户端监听 ZEGO Express SDK 试验性 API 回调 <a id="listen-zego-express-sdk-experimental-api-callback" />

<Note title="说明">该方式更简单，建议使用该方式实现展示用户和智能体实例状态</Note>

通过客户端 SDK 监听 ZEGO Express SDK 的试验性 API 回调（onRecvExperimentalAPI或recvExperimentalAPI），根据消息类型处理对应的状态事件。以下是各平台示例代码：

<Tabs>

<Tab title="iOS">
客户端可以通过实现ZegoEventHandler协议，监听 `onRecvExperimentalAPI` 回调获取 `method` 为 `liveroom.room.on_recive_room_channel_message` 的房间自定义消息。以下是监听回调的示例代码：
<CodeGroup>
```oc YourService.h/m
// 实现ZegoEventHandler协议
@interface YourService () <ZegoEventHandler>
@property (nonatomic, strong) YourViewController *youViewController;
@end

@implementation YourService

// 注意！！！：通过房间自定义消息收到的数据可能会乱序，需要根据 SeqId 字段进行排序。
// 处理express onRecvExperimentalAPI接收到的消息
- (void)onRecvExperimentalAPI:(NSString *)content {
    // 转发给view解析消息内容
    // !mark
    [self.youViewController handleExpressExperimentalAPIContent:content];
}

@end // YourService implementation
```

```oc YourViewController.h/m
// 在头文件中实现ZegoEventHandler协议
@interface YourViewController ()

@end

@implementation YourViewController

// 解析自定义信令消息
- (void)handleExpressExperimentalAPIContent:(NSString *)content {
    // 解析JSON内容
    NSError *error;
    NSData *jsonData = [content dataUsingEncoding:NSUTF8StringEncoding];
    NSDictionary *contentDict = [NSJSONSerialization JSONObjectWithData:jsonData
                                                        options:NSJSONReadingMutableContainers
                                                          error:&error];
    if (error || !contentDict) {
        NSLog(@"JSON解析失败: %@", error);
        return;
    }
    // 检查是否为房间消息
    NSString *method = contentDict[@"method"];
    if (![method isEqualToString:@"liveroom.room.on_recive_room_channel_message"]) {
        return;
    }
    // 获取消息参数
    NSDictionary *params = contentDict[@"params"];
    if (!params) {
        return;
    }
    NSString *msgContent = params[@"msg_content"];
    NSString *sendIdName = params[@"send_idname"];
    NSString *sendNickname = params[@"send_nickname"];
    NSString *roomId = params[@"roomid"];
    if (!msgContent || !sendIdName || !roomId) {
         NSLog(@"parseExperimentalAPIContent 参数不完整: msgContent=%@, sendIdName=%@, roomId=%@",
                msgContent, sendIdName, roomId);
        return;
    }

    // 典型JSON内容示例：
    // 用户说话状态（Cmd=1）: "{\"Timestamp\":1765510379,\"TimestampMs\":1765510379113,\"SeqId\":278800715,\"Round\":510359002,\"Cmd\":1,\"Legacy\":false,\"Data\":{\"SpeakStatus\":1,\"UserId\":\"38475\"}}"
    // 智能体实例状态（Cmd=6）: "{\"Timestamp\":1765510398,\"TimestampMs\":1765510398029,\"SeqId\":278800725,\"Round\":0,\"Cmd\":6,\"Legacy\":false,\"Data\":{\"OldStatus\":3,\"Status\":0,\"Reason\":\"tts_all_played\"}}"
    // 解析消息内容
    [self handleMessageContent:msgContent userID:sendIdName userName:sendNickname ?: @""];
}

// 处理消息内容
- (void)handleMessageContent:(NSString *)command userID:(NSString *)userID userName:(NSString *)userName{
    NSDictionary* msgDict = [self dictFromJson:command];
    if (!msgDict) {
        return;
    }

    // 解析基本信息
    int cmd = [msgDict[@"Cmd"] intValue];
    int64_t seqId = [msgDict[@"SeqId"] longLongValue];
    int64_t round = [msgDict[@"Round"] longLongValue];
    int64_t timestamp = [msgDict[@"Timestamp"] longLongValue];
    NSDictionary *data = msgDict[@"Data"];

    // 根据命令类型处理消息
    switch (cmd) {
        // !mark
        case 1: // 用户说话状态
            [self handleUserSpeakStatus:data seqId:seqId round:round timestamp:timestamp];
            break;
        // !mark
        case 6: // 智能体实例状态
            [self handleAgentInstanceStatus:data seqId:seqId round:round timestamp:timestamp];
            break;
    }
}

@end // YourViewController implementation
```
</CodeGroup>

</Tab>
<Tab title="Android">
客户端可通过监听 `onRecvExperimentalAPI` 回调获取 `method` 为 `liveroom.room.on_recive_room_channel_message` 的房间自定义消息。以下是监听回调的示例代码：
```java
// 典型JSON内容示例：
// 用户说话状态（Cmd=1）：
// {"method":"liveroom.room.on_recive_room_channel_message","params":{"msg_content":"{\"Timestamp\":1765510379,\"TimestampMs\":1765510379113,\"SeqId\":278800715,\"Round\":510359002,\"Cmd\":1,\"Legacy\":false,\"Data\":{\"SpeakStatus\":1,\"UserId\":\"38475\"}}","msg_type":1,"roomid":"ir_20p158E0","send_idname":"@RBT#38475_xiaozhi-sx_174722027","send_nickname":""}}
// 智能体实例状态（Cmd=6）：
// {"method":"liveroom.room.on_recive_room_channel_message","params":{"msg_content":"{\"Timestamp\":1765510398,\"TimestampMs\":1765510398029,\"SeqId\":278800725,\"Round\":0,\"Cmd\":6,\"Legacy\":false,\"Data\":{\"OldStatus\":3,\"Status\":0,\"Reason\":\"tts_all_played\"}}","msg_type":1,"roomid":"ir_20p158E0","send_idname":"@RBT#38475_xiaozhi-sx_174722027","send_nickname":""}}
ZegoExpressEngine.getEngine().setEventHandler(new IZegoEventHandler() {
    // !mark(1:2)
    @Override
    public void onRecvExperimentalAPI(String content) {
        super.onRecvExperimentalAPI(content);
        try {
            // 第一步：将 content 解析为 JSONObject
            JSONObject json = new JSONObject(content);

            // 第二步：检查 method 字段的值
            if (json.has("method") && json.getString("method")
                .equals("liveroom.room.on_recive_room_channel_message")) {
                // 第三步：获取 params 并解析
                JSONObject paramsObject = json.getJSONObject("params");
                String msgContent = paramsObject.getString("msg_content");

                // JSON 字符串示例见上
                // 将 JSON 字符串解析为 AIAgentCustomMessage 对象
                AIAgentCustomMessage chatMessage = gson.fromJson(msgContent, AIAgentCustomMessage.class);
                // !mark
                if (chatMessage.cmd == 1) { // 用户说话状态
                    handleUserSpeakStatus(chatMessage);
                    // !mark
                } else if (chatMessage.cmd == 6) { // 智能体实例状态
                    handleAgentStatus(chatMessage);
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
});

/**
 * 智能体实例状态和用户说话状态消息结构体
 */
public static class AIAgentCustomMessage {

    @SerializedName(value = "Timestamp", alternate = "timestamp")
    public long timestamp;
    @SerializedName(value = "TimestampMs", alternate = "timestamp_ms")
    public long timestampMs;
    @SerializedName(value = "SeqId", alternate = "seq_id")
    public long seqId;
    @SerializedName(value = "Round", alternate = "round")
    public long round;
    @SerializedName(value = "Cmd", alternate = "cmd")
    public int cmd;
    @SerializedName(value = "Legacy", alternate = "legacy")
    public boolean legacy;
    @SerializedName(value = "Data", alternate = "data")
    public Data data;

    public static class Data {

        // 用户说话状态消息（Cmd=1）
        @SerializedName(value = "SpeakStatus", alternate = "speak_status")
        public int speakStatus; // 1: 说话开始，2: 说话结束
        @SerializedName(value = "UserId", alternate = "user_id")
        public String userId;

        // 智能体实例状态消息（Cmd=6）
        @SerializedName(value = "OldStatus", alternate = "old_status")
        public Integer oldStatus; // 0: 空闲 1: 正在听 2: 正在想 3: 正在说
        @SerializedName(value = "Status", alternate = "status")
        public Integer status; // 0: 空闲 1: 正在听 2: 正在想 3: 正在说
        @SerializedName(value = "Reason", alternate = "reason")
        public String reason;
    }
}
```
</Tab>
<Tab title="Flutter">
客户端可以监听 `onRecvExperimentalAPI` 回调获取 `method` 为 `liveroom.room.on_recive_room_channel_message` 的房间自定义消息。以下是监听回调的示例代码：
```dart
import 'dart:convert';

import 'package:flutter/cupertino.dart';
import 'package:zego_express_engine/zego_express_engine.dart';

class YourPage extends StatefulWidget {
  const YourPage({super.key});

  @override
  State<YourPage> createState() => _YourPageState();
}

class _YourPageState extends State<YourPage> {
  @override
  void initState() {
    super.initState();

    // !mark
    ZegoExpressEngine.onRecvExperimentalAPI = onRecvExperimentalAPI;
  }

  @override
  void dispose() {
    super.dispose();

    ZegoExpressEngine.onRecvExperimentalAPI = null;
  }

  @override
  Widget build(BuildContext context) {
    return YourMessageView();
  }

  /// 用户说话状态（Cmd=1）:
  /// {"Timestamp":1765510379,"TimestampMs":1765510379113,"SeqId":278800715,"Round":510359002,"Cmd":1,"Legacy":false,"Data":{"SpeakStatus":1,"UserId":"38475"}}
  /// 智能体实例状态（Cmd=6）:
  /// {"Timestamp":1765510398,"TimestampMs":1765510398029,"SeqId":278800725,"Round":0,"Cmd":6,"Legacy":false,"Data":{"OldStatus":3,"Status":0,"Reason":"tts_all_played"}}
  void onRecvExperimentalAPI(String content) {
    try {
      /// 检查是否为房间消息
      final contentMap = jsonDecode(content);
      if (contentMap['method'] !=
          'liveroom.room.on_recive_room_channel_message') {
        return;
      }

      final params = contentMap['params'];
      if (params == null) {
        return;
      }

      final msgContent = params['msg_content'];
      if (msgContent == null) {
        return;
      }

      handleMessageContent(msgContent);
    } catch (e) {}
  }

  /// 处理消息内容
  void handleMessageContent(String msgContent) {
    final Map<String, dynamic> json = jsonDecode(msgContent);

    /// 解析基本信息
    final int timestamp = json['Timestamp'] ?? 0;
    final int seqId = json['SeqId'] ?? 0;
    final int round = json['Round'] ?? 0;
    final int cmdType = json['Cmd'] ?? 0;
    final Map<String, dynamic> data =
        json['Data'] != null ? Map<String, dynamic>.from(json['Data']) : {};

    // 根据命令类型处理消息
    switch (cmdType) {
      /// !mark
      case 1:
        /// 用户说话状态
        handleUserSpeakStatus(data, seqId, round, timestamp);
        break;
      /// !mark
      case 6:
        /// 智能体实例状态
        handleAgentInstanceStatus(data, seqId, round, timestamp);
        break;
    }
  }
}
```
</Tab>
<Tab title="Web">
客户端可通过监听 `recvExperimentalAPI` 回调获取 `method` 为 `onRecvRoomChannelMessage` 的房间自定义消息。以下是监听回调的示例代码：

```javascript {2,4,15}
// 用户说话状态（Cmd=1）：
// {"Timestamp":1765510379,"TimestampMs":1765510379113,"SeqId":278800715,"Round":510359002,"Cmd":1,"Legacy":false,"Data":{"SpeakStatus":1,"UserId":"38475"}}
// 智能体实例状态（Cmd=6）：
// {"Timestamp":1765510398,"TimestampMs":1765510398029,"SeqId":278800725,"Round":0,"Cmd":6,"Legacy":false,"Data":{"OldStatus":3,"Status":0,"Reason":"tts_all_played"}}
zg.on("recvExperimentalAPI", (result) => {
  const { method, content } = result;
  // !mark
  if (method === "onRecvRoomChannelMessage") {
    try {
      // 解析消息
      const recvMsg = JSON.parse(content.msgContent);
      const { Cmd, SeqId, Data, Round } = recvMsg;
      // !mark
      if (Cmd === 1) {
        // 用户说话状态消息处理，例如 Data.SpeakStatus 1=开始 2=结束
        handleUserSpeakStatus(Data, SeqId, Round);
        // !mark
      } else if (Cmd === 6) {
        // 智能体实例状态消息处理，例如 Data.Status 0=空闲 1=听 2=想 3=说
        handleAgentStatus(Data, SeqId, Round);
      }
    } catch (error) {
      console.error("解析消息失败:", error);
    }
  }
});
// 启用 onRecvRoomChannelMessage 实验性 API
zg.callExperimentalAPI({ method: "onRecvRoomChannelMessage", params: {} });

```
</Tab>
</Tabs>


### 通过服务端回调监听智能体实例状态和用户说话状态事件，然后通过自有信令通道发送自定义消息到客户端


如果您的应用已经有自己的信令通道，如 WebSocket 或即时通讯系统，您可以：

- 在服务端接收到状态事件回调后，通过您的信令通道将状态信息转发给相关客户端。
- 与客户端约定好消息格式，客户端根据接收到的状态信息更新 UI 界面（如显示说话指示器、动画等）。

这种方式的优点是可以完全控制消息格式和传输逻辑，适合已有成熟信令系统的应用。

#### 监听服务端回调

请参考 [接收回调](./../callbacks/receiving-callback.mdx) 文档开发好用于接收 AI Agent 事件通知的回调，并提供地址联系 ZEGO 技术支持进行配置。
<Note title="说明">

要接收用户和智能体实例状态的回调结果，请在[创建智能体实例](./../api-reference/agent-instance-management/create-agent-instance.mdx)时，配置相应的 [CallbackConfig.UserSpeakAction](./../api-reference/agent-instance-management/create-agent-instance.mdx#callbackconfig) 和 [CallbackConfig.AgentInstanceStatus](./../api-reference/agent-instance-management/create-agent-instance.mdx#callbackconfig) 参数为 `1`。

</Note>

回调内容示例如下：

<CodeGroup>
```json title="智能体实例状态回调" {5,7}
{
    "AppId": 1234567,
    "AgentInstanceId": "1912124734317838336",
    "Data": {
        "Status": "LISTENING",// IDLE: 空闲 LISTENING: 正在听 THINKING: 正在想 SPEAKING: 正在做
    },
    "Event": "AgentInstanceStatus",
    "Nonce": "7450395512627324902",
    "Signature": "fd9c1ce54e85bd92f48b0a805e82a52b0c0c6445",
    "Timestamp": 1745502313000,
    "AgentUserId": "123456789",
    "RoomId": "123456789",
    "Sequence": 123456789,
}
```
```json title="用户说话状态回调" {5,7}
{
    "AppId": 1234567,
    "AgentInstanceId": "1912124734317838336",
    "Data": {
        "Action": "SPEAK_BEGIN",// SPEAK_BEGIN: 开始说话 SPEAK_END: 说话结束
    },
    "Event": "UserSpeakAction",
    "Nonce": "7450395512627324902",
    "Signature": "fd9c1ce54e85bd92f48b0a805e82a52b0c0c6445",
    "Timestamp": 1745502313000,
    "AgentUserId": "123456789",
    "RoomId": "123456789",
    "Sequence": 123456789,
}
```
</CodeGroup>


{/* 暂时不再推荐使用 RTC 房间消息下发


### 如何通知客户端并展示状态

当您通过服务端回调接收到智能体实例或用户的说话状态事件后，您可以将这些状态信息通知到客户端，以便客户端可以实时展示状态变化。以下是两种常用的通知方式：

#### 使用自有信令通道

如果您的应用已经有自己的信令通道，如 WebSocket 或即时通讯系统，您可以：

- 在服务端接收到状态事件回调后，通过您的信令通道将状态信息转发给相关客户端。
- 与客户端约定好消息格式，客户端根据接收到的状态信息更新 UI 界面（如显示说话指示器、动画等）。

这种方式的优点是可以完全控制消息格式和传输逻辑，适合已有成熟信令系统的应用。

#### 借用 ZEGO RTC 房间消息通道，发送自定义消息

如果您没有自己的业务信令通道，可以借用 ZEGO RTC 提供的房间消息功能：

- 在服务端接收到状态事件回调后，调用 ZEGO RTC Server API 发送自定义消息
- 与客户端约定好消息格式，客户端通过 ZEGO RTC SDK 监听自定义消息，接收状态变化通知更新 UI 界面（如显示说话指示器、动画等）

这种方式的优点是无需额外搭建信令系统，可以直接利用 ZEGO 提供的基础设施。但是这种方式的缺点是房间消息不保证完全可靠，且有发送频率限制，不适用于对消息可靠性要求较高的场景。


实现示例如下：
<Tabs>
<Tab title="服务端">

以下是服务端接收到智能体和用户说话状态事件后，通过 ZEGO Server API [发送自定义消息](/real-time-video-server/api-reference/room/send-custom-command)的示例代码：


```javascript {27-30,47-72}
export class AgentCallbackController {
    // 向 RTC 房间发送自定义消息
    private async handleSendCustomCommand(
        commonArgs: any,
        roomId: string,
        agentUserId: string,
        data: any,
    ) {
        try {
            // 构建查询参数，ToUserId[] 以数组形式多次出现
            const params: Record<string, any> = {
                Action: 'SendCustomCommand',
                RoomId: roomId,
                FromUserId: agentUserId,
                MessageContent: JSON.stringify(data),
                ...commonArgs
            };
            // 拼接 ToUserId[]
            const searchParams = new URLSearchParams();
            Object.entries(params).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach(v => searchParams.append(key, v));
                } else {
                    searchParams.append(key, value);
                }
            });
            // 拼接完整 URL
            const url = `https://rtc-api.zego.im/?${searchParams.toString()}`;
            // 直接发起 GET 请求发送自定义消息
            const res = await rtcRequest<any>({ method: 'GET', url });

            if (res.Code !== 0) logger.error(`sendCustomCommand errorCode: ${res.Code}, errorMessage: ${res.Message}`);
        } catch (err) {
            const errMsg = err instanceof Error ? err.message : String(err);
            logger.error('[AgentCallbackController] handleSendCustomCommand error:' + errMsg);
        }
    }
    // 接收智能体实例状态及用户说话状态变化回调
    callbackHandler = async (req: Request, res: Response) => {
        const RequestId = req.headers.RequestId as string;
        const payload = req.body as AIAgentCallbackPayload;
        const { AppId, AgentInstanceId, RoomId, AgentUserId, Event, Data } = payload;

        // commonArgs的生成请参考 https://doc-zh.zego.im/real-time-video-server/api-reference/accessing-server-apis#common-parameters
        const commonArgs = genCommonArgs(AppId, globalConfig.appEnvSecretMap[AppId]);

        switch (Event) {
            case AgentEvent.AgentInstanceStatus: {
                const { Sequence, Status } = Data as AgentInstanceStatusPayload;
                const command = {
                    eventType: 'AgentInstanceStatus',
                    data: {
                        sequence: Sequence,
                        status: Status,
                    },
                };
                await this.handleSendCustomCommand(commonArgs, RoomId, AgentInstanceId, command);
                break;
            }
            case AgentEvent.UserSpeakAction: {
                const { UserId, Sequence, Action } = Data as UserSpeakActionPayload;
                const command = {
                    eventType: 'UserSpeakAction',
                    data: {
                        userId: UserId,
                        sequence: Sequence,
                        action: Action,
                    },
                };
                await this.handleSendCustomCommand(commonArgs, RoomId, AgentInstanceId, command);
                break;
            }
            // ... 其他事件处理
        }
    };
}
```

</Tab>
<Tab title="客户端">

客户端各端接收消息示例代码如下：

<CodeGroup>
```javascript title="Web"
// 3. 客户端通过ZEGO RTC SDK监听自定义消息
    zg.on("IMRecvCustomCommand", (roomID: string, fromUser: ZegoUser, command: string) => {
      try {
        const message = JSON.parse(command);
        switch (message.eventType) {
          case "AgentInstanceStatus":
            // 处理智能体实例状态事件
            // 更新UI
            break;
          case "UserSpeakAction":
            // 处理用户说话状态事件
            // 更新UI
            break;
        }
      } catch (error) {
        console.error("解析消息失败:", error);
      }
    });
```
```objc title="iOS"
@interface YourClass () <ZegoEventHandler>

@end

@implementation YourClass

- (void)onIMRecvCustomCommand:(NSString *)command
                     fromUser:(ZegoUser *)fromUser
                       roomID:(NSString *)roomID{
    if (command == nil) {
        return;
    }

    NSDictionary* msgDict = [ZegoAIAgentUtil dictFromJson:command];
    if (!msgDict) {
        return;
    }

    NSString *eventType = msgDict[@"eventType"];
    if (eventType) {
        if ([eventType isEqualToString:@"AgentInstanceStatus"]) {
            // 处理智能体实例状态事件
            // 更新UI
        } else if ([eventType isEqualToString:@"UserSpeakAction"]) {
            // 处理用户说话状态事件
            // 更新UI
        }
    }
}
@end
```
```java title="Android"
// 客户端通过ZEGO RTC SDK监听自定义消息
ZegoExpressEngine.getEngine().setEventHandler(new IZegoEventHandler() {
    @Override
    public void onIMRecvCustomCommand(String roomID, ZegoUser fromUser, String command) {
        super.onIMRecvCustomCommand(roomID, fromUser, command);
        try {
            // 第一步：将 content 解析为 JSONObject
            JSONObject json = new JSONObject(command);
            if (json.has("eventType")) {
                String eventType = json.getString("eventType");
                if ("AgentInstanceStatus".equals(eventType)) {
                    // 处理智能体实例状态事件
                    // 更新UI
                } else if ("UserSpeakAction".equals(eventType)) {
                    // 处理用户说话状态事件
                    // 更新UI
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
});
```
</CodeGroup>

</Tab>
</Tabs>

*/}