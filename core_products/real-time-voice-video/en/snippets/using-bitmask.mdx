<Accordion title="Using Bitmask" defaultOpen="false">


**Application Scenarios**

All numbers in a program are stored in binary form in the computer's memory, while bitwise operations directly operate on the binary bits of integers in memory.

| Symbol | Meaning      | Operation Rules                                                                 | Example                                                      |
| ------ | ------------ | --------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| &      | AND          | The result is 1 only when both bits are 1.                                            | 0&1=0, 1&1=1.                                               |
| \|     | OR           | The result is 0 only when both bits are 0.                                            | 0\|0=0, 0\|1=1.                                             |
| ^      | XOR          | Same bits are 0, different bits are 1.                                               | 1^1=0, 0^1=1.                                               |
| ~      | NOT          | 0 becomes 1, 1 becomes 0.                                                        | ~1=0, ~0=1.                                                 |
| \<\<    | Left Shift   | Shift all bits to the left by the corresponding number of positions in binary form, high bits are shifted out (discarded), and low bits are filled with zeros. | For example, the binary of integer 3 is 00000011, 3 \<\< 2 left shift by 2 positions is 00001100. |
| \>\>    | Signed Right Shift   | Shift all bits to the right by the corresponding number of positions in binary form, low bits are shifted out (discarded), and high bits are filled with the sign bit, i.e., positive numbers are filled with 0, negative numbers are filled with 1. | For example, the binary of integer 3 is 00000011, 3 \>\> 1 signed right shift by 1 position is 00000001. |
| \>\>\>   | Unsigned Right Shift   | Shift all bits to the right by the corresponding number of positions in binary form, low bits are shifted out (discarded), and high bits are filled with zeros. For positive numbers, this is the same as signed right shift, but different for negative numbers. | For example, the binary of integer 3 is 00000011, 3 \>\>\> 1 unsigned right shift by 1 position is 00000001. |

The SDK mainly uses the bitmask principle to implement multiple switch operations, that is, when multiple module switches need to be selected in an API, developers need to pass the bitmask result to the SDK.

**Examples**

Taking the raw audio and video data acquisition function as an example, the bitmask usage examples for different languages are as follows:

<CodeGroup>
```cpp C++
enum ZegoAudioDataCallbackBitMask
{
    /** This property controls whether the SDK triggers the [onCapturedAudioData] method callback */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_CAPTURED = 1 << 0,

    /** This property controls whether the SDK triggers the [onPlaybackAudioData] method callback */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_PLAYBACK = 1 << 1,

    /** This property controls whether the SDK triggers the [onMixedAudioData] method callback */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_MIXED = 1 << 2,

    /** This property controls whether the SDK triggers the [onPlayerAudioData] method callback */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_PLAYER = 1 << 3
};

// Enable the SDK to acquire raw audio data, specifying that the SDK needs to trigger both captured audio data callback and playback audio data callback
unsigned int bitmask = ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_CAPTURED | ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_PLAYBACK;
engine->startAudioDataObserver(bitmask, param);
```

```objc Objective-C
typedef NS_OPTIONS(NSUInteger, ZegoAudioDataCallbackBitMask) {
    /// This property controls whether the SDK triggers the [onCapturedAudioData] method callback
    ZegoAudioDataCallbackBitMaskCaptured = 1 << 0,
    /// This property controls whether the SDK triggers the [onPlaybackAudioData] method callback
    ZegoAudioDataCallbackBitMaskPlayback = 1 << 1,
    /// This property controls whether the SDK triggers the [onMixedAudioData] method callback
    ZegoAudioDataCallbackBitMaskMixed = 1 << 2,
    /// This property controls whether the SDK triggers the [onPlayerAudioData] method callback
    ZegoAudioDataCallbackBitMaskPlayer = 1 << 3
};

// Enable the SDK to acquire raw audio data, specifying that the SDK needs to trigger both captured audio data callback and playback audio data callback
ZegoAudioDataCallbackBitMask bitmask = ZegoAudioDataCallbackBitMaskCaptured | ZegoAudioDataCallbackBitMaskPlayback;
[[ZegoExpressEngine sharedEngine] startAudioDataObserver:bitmask param:param];
```

```java Java
public enum ZegoAudioDataCallbackBitMask {
    /** This property controls whether the SDK triggers the [onCapturedAudioData] method callback */
    CAPTURED(1 << 0),
    /** This property controls whether the SDK triggers the [onPlaybackAudioData] method callback */
    PLAYBACK(1 << 1),
    /** This property controls whether the SDK triggers the [onMixedAudioData] method callback */
    MIXED(1 << 2),
    /** This property controls whether the SDK triggers the [onPlayerAudioData] method callback */
    PLAYER(1 << 3);
}

// Enable the SDK to acquire raw audio data, specifying that the SDK needs to trigger both captured audio data callback and playback audio data callback
int bitmask = 0;
bitmask |= ZegoAudioDataCallbackBitMask.CAPTURED.value();
bitmask |= ZegoAudioDataCallbackBitMask.PLAYBACK.value();
engine.startAudioDataObserver(bitmask, param);
```
</CodeGroup>


</Accordion>