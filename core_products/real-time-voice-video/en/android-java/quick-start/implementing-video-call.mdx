---
articleID: 7627
date: "2025-01-21"
---
# Implement Video Call

---



## Feature Overview

This article will introduce how to quickly implement a simple real-time audio and video call.

Explanation of related concepts:

- ZEGO Express SDK: A real-time audio and video SDK provided by ZEGO that can provide developers with convenient access, high definition and smoothness, multi-platform interoperability, low latency, and high concurrency audio and video services.
- Stream: Refers to a group of audio and video data that is continuously being sent, encapsulated in a specified encoding format. A user can publish multiple streams at the same time (for example, one for camera data and one for screen sharing data) and can also play multiple streams at the same time. Each stream is identified by a stream ID (streamID).
- Publish stream: The process of pushing the packaged audio and video data stream to ZEGO real-time audio and video cloud.
- Play stream: The process of pulling and playing existing audio and video data streams from ZEGO real-time audio and video cloud.
- Room: An audio and video space service provided by ZEGO, used to organize user groups. Users in the same room can send and receive real-time audio, video, and messages to each other.
    1. Users need to log in to a room first before they can publish and play streams.
    2. Users can only receive related messages in the room they are in (users entering and leaving, audio and video stream changes, etc.).
    3. Each room is identified by a unique roomID within an AppID. All users who log in to the room using the same roomID belong to the same room.



For more related concepts, please refer to [Term Explanation](/glossary/term-explanation).

## Prerequisites

Before implementing basic real-time audio and video functionality, please ensure:

- You have integrated ZEGO Express SDK in your project and implemented basic real-time audio and video functionality. For details, please refer to [Quick Start - Integration](/real-time-video-android-java/quick-start/integrating-sdk).
- You have created a project in the [ZEGO Console](https://console.zego.im) and applied for a valid AppID and AppSign. For details, please refer to "Project Information" in [Console - Project Management](/console/project-info).

<Warning title="Attention">

The SDK also supports Token authentication. If you have higher security requirements for your project, it is recommended that you upgrade your authentication method. For details, please refer to [How to upgrade from AppSign authentication to Token authentication](http://doc-zh.zego.im/faq/token_upgrade?product=ExpressVideo).
</Warning>

## Example Code
We provide example code for implementing the basic process of video calls, which can be used as a reference during development.
<Accordion title="xml interface code" defaultOpen="false">
```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/coordinatorLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">


    <TextureView
        android:id="@+id/preview"
        android:layout_width="wrap_content"
        android:layout_height="731dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <Button
        android:id="@+id/startButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Start Call"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/appBarLayout" />

    <Button
        android:id="@+id/stopButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Stop Call"
        app:iconTint="#E65A5A"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/startButton" />

    <com.google.android.material.appbar.AppBarLayout
        android:id="@+id/appBarLayout"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="?attr/colorPrimary" />

    </com.google.android.material.appbar.AppBarLayout>

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/fab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginEnd="16dp"
        android:layout_marginRight="16dp"
        android:layout_marginBottom="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:srcCompat="@android:drawable/ic_dialog_email" />

    <TextureView
        android:id="@+id/remoteUserView"
        android:layout_width="150dp"
        android:layout_height="220dp"
        android:layout_marginTop="30dp"
        android:layout_marginEnd="30dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/appBarLayout" />

</androidx.constraintlayout.widget.ConstraintLayout>
```
</Accordion>

<Accordion title="Implement video call code" defaultOpen="false">
```java
package com.zego.express.demo.helloworld;

import android.content.pm.PackageManager;
import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;

import android.view.View;

import android.widget.Toast;

import org.json.JSONObject;

import java.util.ArrayList;

import im.zego.zegoexpress.ZegoExpressEngine;
import im.zego.zegoexpress.callback.IZegoDestroyCompletionCallback;
import im.zego.zegoexpress.callback.IZegoEventHandler;
import im.zego.zegoexpress.constants.ZegoPlayerState;
import im.zego.zegoexpress.constants.ZegoPublisherState;
import im.zego.zegoexpress.constants.ZegoRoomStateChangedReason;
import im.zego.zegoexpress.constants.ZegoScenario;
import im.zego.zegoexpress.constants.ZegoStreamQualityLevel;
import im.zego.zegoexpress.constants.ZegoUpdateType;
import im.zego.zegoexpress.entity.ZegoCanvas;
import im.zego.zegoexpress.entity.ZegoEngineProfile;
import im.zego.zegoexpress.entity.ZegoRoomConfig;
import im.zego.zegoexpress.entity.ZegoStream;
import im.zego.zegoexpress.entity.ZegoUser;

public class MainActivity extends AppCompatActivity {

    ZegoExpressEngine engine;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Request corresponding camera and recording permissions before the call
        requestPermission();

        // Start call button
        findViewById(R.id.startButton).setOnClickListener(new View.OnClickListener() {
            // Click to start call
            @Override
            public void onClick(View view) {
                // Create Express SDK instance
                createEngine();
                // Listen to common events
                setEventHandler();
                // Login to room
                loginRoom();
                // Start preview and publish stream
                startPublish();
            }
        });

        // Stop call button
        findViewById(R.id.stopButton).setOnClickListener(new View.OnClickListener() {
            // Click to stop call
            @Override
            public void onClick(View view) {
                engine.logoutRoom();
                ZegoExpressEngine.destroyEngine(new IZegoDestroyCompletionCallback() {
                    @Override
                    public void onDestroyCompletion() {
                        // Destroy successful
                    }
                });

            }
        });
    }

    // Request camera and recording permissions
    private void requestPermission() {
        String[] permissionNeeded = {
                "android.permission.CAMERA",
                "android.permission.RECORD_AUDIO"};
        if (ContextCompat.checkSelfPermission(getApplicationContext(), "android.permission.CAMERA") != PackageManager.PERMISSION_GRANTED ||
            ContextCompat.checkSelfPermission(getApplicationContext(), "android.permission.RECORD_AUDIO") != PackageManager.PERMISSION_GRANTED) {
            requestPermissions(permissionNeeded, 101);
        }
    }

    // Create ZegoExpress instance, listen to common events
    void createEngine() {
        // Create engine, general scenario access, and register self as eventHandler callback
        // If you don't need to register callbacks, the eventHandler parameter can be passed as null, and you can call the "setEventHandler:" method later to set callbacks
        ZegoEngineProfile profile = new ZegoEngineProfile();
        profile.appID = ;  // Please obtain through official website registration, format: 1234567890L
        profile.appSign = ; //Please obtain through official website registration, format: "0123456789012345678901234567890123456789012345678901234567890123" (64 characters in total)
        profile.scenario = ZegoScenario.DEFAULT;  // General scenario access
        profile.application = getApplication();
        engine = ZegoExpressEngine.createEngine(profile, null);
    }

    //Login to room
    void loginRoom() {
        // The constructor method public ZegoUser(String userID) of ZegoUser will set "userName" to be the same as the passed parameter "userID". "userID" and "userName" cannot be "null" otherwise it will cause login room failure.
        ZegoUser user = new ZegoUser("user2");

        ZegoRoomConfig roomConfig = new ZegoRoomConfig();
        //If you use appsign for authentication, you do not need to fill in the token parameter; if you need to use a more secure authentication method: token authentication, please refer to [How to upgrade from AppSign authentication to Token authentication](https://doc-zh.zego.im/faq/token_upgrade?product=ExpressVideo&platform=all)
        //roomConfig.token = ;
        // Only when passing ZegoRoomConfig with "isUserStatusNotify" parameter value of "true" can you receive the onRoomUserUpdate callback.
        roomConfig.isUserStatusNotify = true;

        // roomID is generated locally by you, need to ensure "roomID" is globally unique. Different users need to log in to the same room to make calls
        String roomID = "room1";

        // Login to room
        engine.loginRoom(roomID, user, roomConfig, (int error, JSONObject extendedData)->{
            // Login room result, if you only care about the login result, just focus on this callback
            if (error == 0) {
                // Login successful
                Toast.makeText(this, "Login successful", Toast.LENGTH_LONG).show();
            } else {
                // Login failed, please refer to errorCode description /real-time-video-android-java/client-sdk/error-code
                Toast.makeText(this, "Login failed, please refer to errorCode description /real-time-video-android-java/client-sdk/error-code", Toast.LENGTH_LONG).show();
            }
        });
    }

    //Preview and publish stream
    void startPublish() {
        // Set local preview view and start preview, view mode uses SDK default mode, proportional scaling fills the entire View
        ZegoCanvas previewCanvas = new ZegoCanvas(findViewById(R.id.preview));;
        engine.startPreview(previewCanvas);

        // Start publishing stream
        // User calls this interface to publish stream after calling loginRoom
        // Under the same AppID, developers need to ensure "streamID" is globally unique. If different users each publish a stream with the same "streamID", the user who publishes later will fail to publish.
        engine.startPublishingStream("stream2");
    }

    void setEventHandler() {
        engine.setEventHandler(new IZegoEventHandler() {

            @Override
            // When other users in the room publish/stop publishing streams, we will receive notifications of the addition/deletion of corresponding users' audio and video streams here
            public void onRoomStreamUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoStream> streamList, JSONObject extendedData) {
                super.onRoomStreamUpdate(roomID, updateType, streamList, extendedData);
                //When updateType is ZegoUpdateType.ADD, it means there is a new audio and video stream. At this time, we can call the startPlayingStream interface to pull and play this audio and video stream
                if (updateType == ZegoUpdateType.ADD) {
                    // Start playing stream, set remote play rendering view, view mode uses SDK default mode, proportional scaling fills the entire View
                    ZegoStream stream = streamList.get(0);
                    String playStreamID = stream.streamID;
                    // The following remoteUserView is a TextureView on the UI interface. Here, in order to make the example code more concise, we only pull the first stream in the newly added audio and video stream list. In actual business, it is recommended that developers loop through streamList and pull each audio and video stream
                    ZegoCanvas playCanvas = new ZegoCanvas(findViewById(R.id.remoteUserView));
                    engine.startPlayingStream(playStreamID, playCanvas);
                }
            }

            //When other users in the same room enter/leave the room, you can receive notifications through this callback. When the parameter ZegoUpdateType in the callback is ZegoUpdateType.ADD, it means a user has entered the room; when ZegoUpdateType is ZegoUpdateType.DELETE, it means a user has left the room.
            // Only when the isUserStatusNotify parameter in the configuration ZegoRoomConfig passed when logging in to the room loginRoom is true can users receive callbacks of other users in the room.
            // The onRoomUserUpdate callback is not guaranteed to be effective when the number of people in the room exceeds 500. If your business scenario has more than 500 people in the room, please contact ZEGO Technical Support.
            @Override
            public void onRoomUserUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoUser> userList) {
                super.onRoomUserUpdate(roomID, updateType, userList);
                // You can handle corresponding business logic based on user entry/exit in the callback
                if (updateType == ZegoUpdateType.ADD) {
                    for (ZegoUser user : userList) {
                        String text = user.userID + " entered the room";
                        Toast.makeText(getApplicationContext(), text, Toast.LENGTH_LONG).show();
                    }
                } else if (updateType == ZegoUpdateType.DELETE) {
                    for (ZegoUser user : userList) {
                        String text = user.userID + " left the room";
                        Toast.makeText(getApplicationContext(), text, Toast.LENGTH_LONG).show();
                    }
                }
            }

            // Room connection state changed
            @Override
            public void onRoomStateChanged(String roomID, ZegoRoomStateChangedReason reason, int i, JSONObject jsonObject) {
                super.onRoomStateChanged(roomID, reason, i, jsonObject);
                if(reason == ZegoRoomStateChangedReason.LOGINING) {
                    // Logging in to room. When calling [loginRoom] to log in to room or [switchRoom] to switch to target room, enter this state, indicating that a request is being made to connect to the server. Usually this state is used for application interface display.
                } else if(reason == ZegoRoomStateChangedReason.LOGINED) {
                    //Login to room successful. After successfully logging in to or switching rooms, enter this state, indicating that logging in to the room has been successful, and users can normally receive callback notifications for additions and deletions of other users and all stream information in the room.
                    //Only when the room state is login successful or reconnection successful can publish stream (startPublishingStream) and play stream (startPlayingStream) normally send and receive audio and video
                } else if(reason == ZegoRoomStateChangedReason.LOGIN_FAILED) {
                    //Login to room failed. After failing to log in to or switch rooms, enter this state, indicating that logging in to or switching rooms has failed, such as incorrect AppID or Token.
                } else if(reason == ZegoRoomStateChangedReason.RECONNECTING) {
                    //Room connection temporarily interrupted. If the interruption is caused by poor network quality, the SDK will internally retry.
                } else if(reason == ZegoRoomStateChangedReason.RECONNECTED) {
                    //Room reconnection successful. If the interruption is caused by poor network quality, the SDK will internally retry. After successful reconnection, enter this state.
                } else if(reason == ZegoRoomStateChangedReason.RECONNECT_FAILED) {
                    //Room reconnection failed. If the interruption is caused by poor network quality, the SDK will internally retry. After failed reconnection, enter this state.
                } else if(reason == ZegoRoomStateChangedReason.KICK_OUT) {
                    //Kicked out of the room by the server. For example, if the same username logs in to the room elsewhere, causing this end to be kicked out of the room, this state will be entered.
                } else if(reason == ZegoRoomStateChangedReason.LOGOUT) {
                    //Logout from room successful. This is the default state before logging in to the room. After calling [logoutRoom] to successfully logout from the room or [switchRoom] to successfully internally logout from the current room, enter this state.
                } else if(reason == ZegoRoomStateChangedReason.LOGOUT_FAILED) {
                    //Logout from room failed. After calling [logoutRoom] to fail to logout from the room or [switchRoom] to fail to internally logout from the current room, enter this state.
                }
            }

            //User publishes audio and video stream status notification
            //When the status of the user's published audio and video stream changes, this callback will be received. If the network interruption causes publishing exceptions, the SDK will also notify status changes while retrying publishing.
            @Override
            public void onPublisherStateUpdate(String streamID, ZegoPublisherState state, int errorCode, JSONObject extendedData) {
                super.onPublisherStateUpdate(streamID, state, errorCode, extendedData);
                if (errorCode != 0) {
                    //Publishing stream status error
                }
                if (state == ZegoPublisherState.PUBLISHING) {
                    //Publishing stream in progress
                } else if (state == ZegoPublisherState.NO_PUBLISH){
                    //Not publishing stream
                } else if (state == ZegoPublisherState.PUBLISH_REQUESTING){
                    //Requesting to publish stream
                }
            }
            //User plays audio and video stream status notification
            //When the status of the user's played audio and video stream changes, this callback will be received. If the network interruption causes playing exceptions, the SDK will automatically retry.
            @Override
            public void onPlayerStateUpdate(String streamID, ZegoPlayerState state, int errorCode, JSONObject extendedData) {
                super.onPlayerStateUpdate(streamID, state, errorCode, extendedData);
                if (errorCode != 0) {
                    //Playing stream status error
                }
                if (state == ZegoPlayerState.PLAYING) {
                    //Playing stream in progress
                } else if (state == ZegoPlayerState.NO_PLAY){
                    //Not playing stream
                } else if (state == ZegoPlayerState.PLAY_REQUESTING){
                    //Requesting to play stream
                }
            }

            @Override
            public void onNetworkQuality(String userID, ZegoStreamQualityLevel zegoStreamQualityLevel, ZegoStreamQualityLevel zegoStreamQualityLevel1) {
                super.onNetworkQuality(userID, zegoStreamQualityLevel, zegoStreamQualityLevel1);
                if (userID == null) {
                    // Represents the network quality of the local user (me)
                    //("My upstream network quality is %lu", (unsigned long)upstreamQuality);
                    //("My downstream network quality is %lu", (unsigned long)downstreamQuality);
                } else {
                    //Represents the network quality of other users in the room
                    //("User %s's upstream network quality is %lu", userID, (unsigned long)upstreamQuality);
                    //("User %s's downstream network quality is %lu", userID, (unsigned long)downstreamQuality);
                }

                /*
                ZegoStreamQualityLevel.EXCELLENT, Network quality is excellent
                ZegoStreamQualityLevel.GOOD, Network quality is good
                ZegoStreamQualityLevel.MEDIUM, Network quality is normal
                ZegoStreamQualityLevel.BAD, Network quality is poor
                ZegoStreamQualityLevel.DIE, Network is abnormal
                ZegoStreamQualityLevel.UNKNOWN, Network quality is unknown
                */
            }
        });
    }
}

```
</Accordion>

<a id="process"></a>

## Implementation Process

The basic process for users to make video calls through ZEGO Express SDK is:

User A and B join the room. User B previews and publishes the audio and video stream to ZEGO cloud service (publish stream). After User A receives the notification that User B has published the audio and video stream, User A plays User B's audio and video stream (play stream) in the notification.

<Frame width="512" height="auto" caption="">
  <img src="https://doc-media.zego.im/sdk-doc/Pics/Common/ZegoExpressEngine/common_usage_new.png" />
</Frame>

<a id="initialization"> </a>

### Initialization

**1. Create Interface**

According to scenario requirements, create a user interface for video calls for your project. We recommend that you add the following elements to your project:

- Local video window
- Remote video window
- End call button

<Frame width="512" height="auto" caption="">
  <img src="https://doc-media.zego.im/sdk-doc/Pics/QuickStart/express_quickstart_video_call.png" />
</Frame>


**2. Prepare basic work and import related classes and constants of ZEGO Express SDK**

<Accordion title="Example code" defaultOpen="false">
```java
import im.zego.zegoexpress.ZegoExpressEngine;
import im.zego.zegoexpress.callback.IZegoDestroyCompletionCallback;
import im.zego.zegoexpress.callback.IZegoEventHandler;
import im.zego.zegoexpress.constants.ZegoPlayerState;
import im.zego.zegoexpress.constants.ZegoPublisherState;
import im.zego.zegoexpress.constants.ZegoRoomStateChangedReason;
import im.zego.zegoexpress.constants.ZegoScenario;
import im.zego.zegoexpress.constants.ZegoStreamQualityLevel;
import im.zego.zegoexpress.constants.ZegoUpdateType;
import im.zego.zegoexpress.entity.ZegoCanvas;
import im.zego.zegoexpress.entity.ZegoEngineProfile;
import im.zego.zegoexpress.entity.ZegoRoomConfig;
import im.zego.zegoexpress.entity.ZegoStream;
import im.zego.zegoexpress.entity.ZegoUser;
```

```java
ZegoExpressEngine engine;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    // Request corresponding camera and recording permissions before the call
    requestPermission();

    // Start call button
    findViewById(R.id.startButton).setOnClickListener(new View.OnClickListener() {
        // Click to start call
        @Override
        public void onClick(View view) {
            // Create Express SDK instance
            createEngine();
            // Listen to common events
            setEventHandler();
            // Login to room
            loginRoom();
            // Start preview and publish stream
            startPublish();
        }
    });

    // Stop call button
    findViewById(R.id.stopButton).setOnClickListener(new View.OnClickListener() {
        // Click to stop call
        @Override
        public void onClick(View view) {
            engine.logoutRoom();
            ZegoExpressEngine.destroyEngine(new IZegoDestroyCompletionCallback() {
                @Override
                public void onDestroyCompletion() {
                    //Destroy successful
                }
            });

        }
    });
}

//Request camera and recording permissions
private void requestPermission() {
    String[] permissionNeeded = {
            "android.permission.CAMERA",
            "android.permission.RECORD_AUDIO"};
    if (ContextCompat.checkSelfPermission(getApplicationContext(), "android.permission.CAMERA") != PackageManager.PERMISSION_GRANTED ||
        ContextCompat.checkSelfPermission(getApplicationContext(), "android.permission.RECORD_AUDIO") != PackageManager.PERMISSION_GRANTED) {
        //101 is requestCode, can be any number greater than 0, will be passed through to the permission request result callback onRequestPermissionsResult
        requestPermissions(permissionNeeded, 101);
    }
}
```
</Accordion>

<h1 id="CreateEngine"> </h1>

**3. Create Engine**

Call the [createEngine ](@createEngine) interface and pass the applied AppID and AppSign into the parameters "appID" and "appSign".

Select an appropriate scenario according to the actual audio and video business of the App. Please refer to the [Scenario-based Audio and Video Configuration](/real-time-video-android-java/quick-start/scenario-based-audio-video-configuration) document and pass the selected scenario enumeration into the parameter "scenario".


<Warning title="Attention">


The SDK also supports Token authentication. If you have higher security requirements for your project, it is recommended that you upgrade your authentication method. For details, please refer to [How to upgrade from AppSign authentication to Token authentication](http://doc-zh.zego.im/faq/token_upgrade?product=ExpressVideo).
</Warning>
<Warning title="Attention">If it is a voice scenario, please be sure to call `enableCamera(false)` to turn off the camera to avoid starting video capture and publishing stream generating additional video traffic.</Warning>
```java
// Create ZegoExpress instance, listen to common events
void createEngine() {
    ZegoEngineProfile profile = new ZegoEngineProfile();
    profile.appID = appID;  // Please obtain through official website registration, format: 1234567890L
    profile.appSign = appSign; //Please obtain through official website registration, format: @"0123456789012345678901234567890123456789012345678901234567890123" (64 characters in total)
    profile.scenario = ZegoScenario.BROADCAST;  // Specify using live scenario (please fill in the scenario suitable for your business according to the actual situation)
    profile.application = getApplication();
    engine = ZegoExpressEngine.createEngine(profile, null);
}
```

**4. Set Callback**

You can listen to and handle event callbacks you care about by implementing specific methods in the [IZegoEventHandler](@-IZegoEventHandler) interface (or through anonymous inner classes). Then pass the object of the interface implementation class (or anonymous inner class) as the `eventHandler` parameter to the [createEngine ](@createEngine) method or pass it to [setEventHandler](@setEventHandler-ZegoExpressEngine) to register the callback.

<Warning title="Attention">


It is recommended to register callbacks when creating the engine or immediately after creating the engine to avoid delaying registration and missing event notifications.
</Warning>

<Accordion title="Common notification callbacks" defaultOpen="false">
```java
void setEventHandler() {
        engine.setEventHandler(new IZegoEventHandler() {
            @Override
            // When other users in the room publish/stop publishing streams, we will receive notifications of the addition/deletion of corresponding users' audio and video streams here
            public void onRoomStreamUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoStream> streamList, JSONObject extendedData) {
                super.onRoomStreamUpdate(roomID, updateType, streamList, extendedData);
                //When updateType is ZegoUpdateType.ADD, it means there is a new audio and video stream. At this time, we can call the startPlayingStream interface to pull and play this audio and video stream
                if (updateType == ZegoUpdateType.ADD) {
                    // Start playing stream, set remote play rendering view, view mode uses SDK default mode, proportional scaling fills the entire View
                    ZegoStream stream = streamList.get(0);
                    String playStreamID = stream.streamID;
                    // The following remoteUserView is a TextureView on the UI interface. Here, in order to make the example code more concise, we only pull the first stream in the newly added audio and video stream list. In actual business, it is recommended that developers loop through streamList and pull each audio and video stream
                    ZegoCanvas playCanvas = new ZegoCanvas(findViewById(R.id.remoteUserView));
                    engine.startPlayingStream(playStreamID, playCanvas);
                }
            }

            //When other users in the same room enter/leave the room, you can receive notifications through this callback. When the parameter ZegoUpdateType in the callback is ZegoUpdateType.ADD, it means a user has entered the room; when ZegoUpdateType is ZegoUpdateType.DELETE, it means a user has left the room.
            // Only when the isUserStatusNotify parameter in the configuration ZegoRoomConfig passed when logging in to the room loginRoom is true can users receive callbacks of other users in the room.
            // The onRoomUserUpdate callback is not guaranteed to be effective when the number of people in the room exceeds 500. If your business scenario has more than 500 people in the room, please contact ZEGO Technical Support.
            @Override
            public void onRoomUserUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoUser> userList) {
                super.onRoomUserUpdate(roomID, updateType, userList);
                // You can handle corresponding business logic based on user entry/exit in the callback
                if (updateType == ZegoUpdateType.ADD) {
                    for (ZegoUser user : userList) {
                        String text = user.userID + " entered the room";
                        Toast.makeText(getApplicationContext(), text, Toast.LENGTH_LONG).show();
                    }
                } else if (updateType == ZegoUpdateType.DELETE) {
                    for (ZegoUser user : userList) {
                        String text = user.userID + " left the room";
                        Toast.makeText(getApplicationContext(), text, Toast.LENGTH_LONG).show();
                    }
                }
            }

            // Room connection state changed
            @Override
            public void onRoomStateChanged(String roomID, ZegoRoomStateChangedReason reason, int i, JSONObject jsonObject) {
                super.onRoomStateChanged(roomID, reason, i, jsonObject);
                if(reason == ZegoRoomStateChangedReason.LOGINING) {
                    // Logging in to room. When calling [loginRoom] to log in to room or [switchRoom] to switch to target room, enter this state, indicating that a request is being made to connect to the server. Usually this state is used for application interface display.
                } else if(reason == ZegoRoomStateChangedReason.LOGINED) {
                    //Login to room successful. After successfully logging in to or switching rooms, enter this state, indicating that logging in to the room has been successful, and users can normally receive callback notifications for additions and deletions of other users and all stream information in the room.
                    //Only when the room state is login successful or reconnection successful can publish stream (startPublishingStream) and play stream (startPlayingStream) normally send and receive audio and video
                } else if(reason == ZegoRoomStateChangedReason.LOGIN_FAILED) {
                    //Login to room failed. After failing to log in to or switch rooms, enter this state, indicating that logging in to or switching rooms has failed, such as incorrect AppID or Token.
                } else if(reason == ZegoRoomStateChangedReason.RECONNECTING) {
                    //Room connection temporarily interrupted. If the interruption is caused by poor network quality, the SDK will internally retry.
                } else if(reason == ZegoRoomStateChangedReason.RECONNECTED) {
                    //Room reconnection successful. If the interruption is caused by poor network quality, the SDK will internally retry. After successful reconnection, enter this state.
                } else if(reason == ZegoRoomStateChangedReason.RECONNECT_FAILED) {
                    //Room reconnection failed. If the interruption is caused by poor network quality, the SDK will internally retry. After failed reconnection, enter this state.
                } else if(reason == ZegoRoomStateChangedReason.KICK_OUT) {
                    //Kicked out of the room by the server. For example, if the same username logs in to the room elsewhere, causing this end to be kicked out of the room, this state will be entered.
                } else if(reason == ZegoRoomStateChangedReason.LOGOUT) {
                    //Logout from room successful. This is the default state before logging in to the room. After calling [logoutRoom] to successfully logout from the room or [switchRoom] to successfully internally logout from the current room, enter this state.
                } else if(reason == ZegoRoomStateChangedReason.LOGOUT_FAILED) {
                    //Logout from room failed. After calling [logoutRoom] to fail to logout from the room or [switchRoom] to fail to internally logout from the current room, enter this state.
                }
            }

            //User publishes audio and video stream status notification
            //When the status of the user's published audio and video stream changes, this callback will be received. If the network interruption causes publishing exceptions, the SDK will also notify status changes while retrying publishing.
            @Override
            public void onPublisherStateUpdate(String streamID, ZegoPublisherState state, int errorCode, JSONObject extendedData) {
                super.onPublisherStateUpdate(streamID, state, errorCode, extendedData);
                if (errorCode != 0) {
                    //Publishing stream status error
                }
                if (state == ZegoPublisherState.PUBLISHING) {
                    //Publishing stream in progress
                } else if (state == ZegoPublisherState.NO_PUBLISH){
                    //Not publishing stream
                } else if (state == ZegoPublisherState.PUBLISH_REQUESTING){
                    //Requesting to publish stream
                }
            }
            //User plays audio and video stream status notification
            //When the status of the user's played audio and video stream changes, this callback will be received. If the network interruption causes playing exceptions, the SDK will automatically retry.
            @Override
            public void onPlayerStateUpdate(String streamID, ZegoPlayerState state, int errorCode, JSONObject extendedData) {
                super.onPlayerStateUpdate(streamID, state, errorCode, extendedData);
                if (errorCode != 0) {
                    //Playing stream status error
                }
                if (state == ZegoPlayerState.PLAYING) {
                    //Playing stream in progress
                } else if (state == ZegoPlayerState.NO_PLAY){
                    //Not playing stream
                } else if (state == ZegoPlayerState.PLAY_REQUESTING){
                    //Requesting to play stream
                }
            }

            @Override
            public void onNetworkQuality(String userID, ZegoStreamQualityLevel zegoStreamQualityLevel, ZegoStreamQualityLevel zegoStreamQualityLevel1) {
                super.onNetworkQuality(userID, zegoStreamQualityLevel, zegoStreamQualityLevel1);
                if (userID == null) {
                    // Represents the network quality of the local user (me)
                    //("My upstream network quality is %lu", (unsigned long)upstreamQuality);
                    //("My downstream network quality is %lu", (unsigned long)downstreamQuality);
                } else {
                    //Represents the network quality of other users in the room
                    //("User %s's upstream network quality is %lu", userID, (unsigned long)upstreamQuality);
                    //("User %s's downstream network quality is %lu", userID, (unsigned long)downstreamQuality);
                }

                /*
                ZegoStreamQualityLevel.EXCELLENT, Network quality is excellent
                ZegoStreamQualityLevel.GOOD, Network quality is good
                ZegoStreamQualityLevel.MEDIUM, Network quality is normal
                ZegoStreamQualityLevel.BAD, Network quality is poor
                ZegoStreamQualityLevel.DIE, Network is abnormal
                ZegoStreamQualityLevel.UNKNOWN, Network quality is unknown
                */
            }
        });
}
```

</Accordion>


<a id="createroom"></a>

### Login to Room

You can call the [loginRoom ](@loginRoom) interface to log in to the room. If the room does not exist, calling this interface will create and log in to this room. The parameters roomID and user are generated locally by you, but need to meet the following conditions:

- Within the same AppID, need to ensure "roomID" is globally unique.
- Within the same AppID, need to ensure "userID" is globally unique. It is recommended that developers associate "userID" with their own business account system.

```java
//Login to room
void loginRoom() {
    // The constructor method public ZegoUser(String userID) of ZegoUser will set "userName" to be the same as the passed parameter "userID". "userID" cannot be "null" otherwise it will cause login room failure.
    ZegoUser user = new ZegoUser("user2");

    ZegoRoomConfig roomConfig = new ZegoRoomConfig();
    //If you use appsign for authentication, you do not need to fill in the token parameter; if you need to use a more secure authentication method: token authentication, please refer to [How to upgrade from AppSign authentication to Token authentication](https://doc-zh.zego.im/faq/token_upgrade?product=ExpressVideo&platform=all)
    //roomConfig.token = ;
    // Only when passing ZegoRoomConfig with "isUserStatusNotify" parameter value of "true" can you receive the onRoomUserUpdate callback.
    roomConfig.isUserStatusNotify = true;

    // roomID is generated locally by you, need to ensure "roomID" is globally unique. Different users need to log in to the same room to make calls
    String roomID = "room1";

    // Login to room
    engine.loginRoom(roomID, user, roomConfig, (int error, JSONObject extendedData)->{
        // Login room result, if you only care about the login result, just focus on this callback
        if (error == 0) {
            // Login successful
            Toast.makeText(this, "Login successful", Toast.LENGTH_LONG).show();
        } else {
            // Login failed, please refer to errorCode description /real-time-video-android-java/client-sdk/error-code
            Toast.makeText(this, "Login failed, please refer to errorCode description /real-time-video-android-java/client-sdk/error-code", Toast.LENGTH_LONG).show();
        }
    });
}
```



#### Login State (Room Connection State) Callback

After calling the login room interface, you can monitor your connection status in the room in real time by listening to the [onRoomStateChanged](@onRoomStateChanged) callback.

<a id="publishingStream"></a>

### Preview Your Own Video and Publish to ZEGO Audio and Video Cloud

**1. (Optional) Preview Your Own Video**

<Note title="Description">


Regardless of whether you call [startPreview ](@startPreview) to preview, you can publish your audio and video stream to ZEGO audio and video cloud.
</Note>

If you want to see the local video, you can call the [startPreview ](@startPreview) interface to set the preview view and start local preview.

**2. Publish Your Audio and Video Stream to ZEGO Audio and Video Cloud**

After the user calls the [loginRoom ](@loginRoom) interface, you can directly call the [startPublishingStream ](@startPublishingStream) interface and pass in "streamID" to publish your audio and video stream to ZEGO audio and video cloud. You can know whether the publishing is successful by listening to the [onPublisherStateUpdate ](@onPublisherStateUpdate) callback.

"streamID" is generated locally by you, but needs to ensure:

Under the same AppID, "streamID" is globally unique. If under the same AppID, different users each publish a stream with the same "streamID", the user who publishes later will fail to publish.

```java
//Preview and publish stream
void startPublish() {
    // Set local preview view and start preview, view mode uses SDK default mode, proportional scaling fills the entire View
    ZegoCanvas previewCanvas = new ZegoCanvas(findViewById(R.id.preview));;
    engine.startPreview(previewCanvas);

    // Start publishing stream
    // User calls this interface to publish stream after calling loginRoom
    // Under the same AppID, developers need to ensure "streamID" is globally unique. If different users each publish a stream with the same "streamID", the user who publishes later will fail to publish.
    engine.startPublishingStream("stream2");
}
```

<Note title="Description">If you need to know about ZEGO Express SDK's camera/video/microphone/audio/speaker related interfaces, please refer to [FAQ - How to implement switching camera/video screen/microphone/audio/speaker?](http://doc-zh.zego.im/faq/How_to_switch_devices).</Note>

<a id="PlayingStream"></a>

### Play Other Users' Audio and Video

When making video calls, we need to play other users' audio and video.

When other users in the same room publish audio and video streams to ZEGO audio and video cloud, we will receive notifications of new audio and video streams in the [onRoomStreamUpdate](@onRoomStreamUpdate) callback, and can obtain the "streamID" of a certain stream through ZegoStream.

We can call [startPlayingStream](@startPlayingStream__1) in this callback and pass in "streamID" to play this user's audio and video. You can know whether the audio and video were successfully played by listening to the [onPlayerStateUpdate ](@onPlayerStateUpdate) callback.

```java
// Listen to callbacks
void setEventHandler() {
        engine.setEventHandler(new IZegoEventHandler() {
            @Override
            // When other users in the room publish/stop publishing streams, we will receive notifications of the addition/deletion of corresponding users' audio and video streams here
            public void onRoomStreamUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoStream> streamList, JSONObject extendedData) {
                super.onRoomStreamUpdate(roomID, updateType, streamList, extendedData);
                //When updateType is ZegoUpdateType.ADD, it means there is a new audio and video stream. At this time, we can call the startPlayingStream interface to pull and play this audio and video stream
                if (updateType == ZegoUpdateType.ADD) {
                    // Start playing stream, set remote play rendering view, view mode uses SDK default mode, proportional scaling fills the entire View
                    ZegoStream stream = streamList.get(0);
                    String playStreamID = stream.streamID;
                    // The following remoteUserView is a TextureView on the UI interface. Here, in order to make the example code more concise, we only pull the first stream in the newly added audio and video stream list. In actual business, it is recommended that developers loop through streamList and pull each audio and video stream
                    ZegoCanvas playCanvas = new ZegoCanvas(findViewById(R.id.remoteUserView));
                    engine.startPlayingStream(playStreamID, playCanvas);
                }
            }
        });
}
```

#### Notes

If users encounter related errors during audio and video calls, please check [Error Codes](/real-time-video-android-java/client-sdk/error-code).

### Test Publish and Play Stream Functionality Online

Run the project on a real device. After running successfully, you can see the local video screen.

For convenience, ZEGO provides a [Web Debugging Example](https://zegodev.github.io/zego-express-webrtc-sample/assistDev/index.html). On this page, enter the same AppID and RoomID, enter different UserIDs and corresponding [Token](/console/development-assistance/temporary-token), and you can join the same room to communicate with real device. When the audio and video call starts successfully, you can hear remote audio and see remote video screen.



### Stop Audio and Video Call

<a id="stopPublishingStream"></a>

#### Stop Publishing and Playing Audio and Video Streams

**1. Stop Publishing Stream, Stop Preview**

Call the [stopPublishingStream ](@stopPublishingStream) interface to stop sending local audio and video streams to remote users.

```java
// Stop publishing stream
engine.stopPublishingStream();
```

If local preview is enabled, call the [stopPreview ](@stopPreview) interface to stop preview.

```java
// Stop local preview
engine.stopPreview();
```

<a id="stopPlaying"></a>

**2. Stop Playing Stream**

Call the [stopPlayingStream ](@stopPlayingStream) interface to stop playing remote published audio and video streams.

<Warning title="Attention">
If developers receive a notification of audio and video stream "decrease" through the [onRoomStreamUpdate](@onRoomStreamUpdate) callback, please call the [stopPlayingStream](@stopPlayingStream) interface to stop playing in time to avoid playing empty streams and generating additional costs; or, developers can choose the appropriate timing according to their own business needs and actively call the [stopPlayingStream](@stopPlayingStream) interface to stop playing.
</Warning>

```java
// Stop playing stream
engine.stopPlayingStream("stream1");
```

<a id="logoutRoom"></a>

#### Logout Room

Call the [logoutRoom ](@logoutRoom) interface to leave the room.

```java
// Logout room
engine.logoutRoom();
```

<a id="destroy"></a>

#### Destroy Engine

If the user completely no longer uses audio and video functions, you can call the [destroyEngine ](@destroyEngine) interface to destroy the engine and release resources such as microphone, camera, memory, CPU, etc.

- If you need to listen to callbacks to ensure that device hardware resources are released, you can pass "callback" when destroying the engine. This callback is only used for sending notifications. Developers cannot release engine-related resources in the callback.

- If you don't need to listen to callbacks, you can pass "null".

```java
ZegoExpressEngine.destroyEngine(null);
```

## Video Call API Call Sequence

<Frame width="512" height="auto" caption=""><img src="https://doc-media.zego.im/sdk-doc/Pics/QuickStart/quickstart_uml.png" /></Frame>

## FAQ

<Accordion title="Can I directly kill the process when calling logoutRoom to logout from the room?" defaultOpen="false">
After calling [logoutRoom ](@logoutRoom), directly killing the process has a certain probability of causing the [logoutRoom ](@logoutRoom) command to not be sent out. Then the ZEGO server can only consider that this user has left the room after waiting for the heartbeat timeout. To ensure that the [logoutRoom ](@logoutRoom) command is sent out, it is recommended to call [destroyEngine ](@destroyEngine) again and wait for the callback before killing the process.
</Accordion>
## Related Documents
- [Common Error Codes](/real-time-video-android-java/client-sdk/error-code)
- [How to handle room and user related issues?](https://doc-zh.zego.im/faq/express_room?product=ExpressVideo&platform=all)
- [How to set and get SDK logs and stack information?](https://doc-zh.zego.im/faq/express_sdkLog?product=ExpressVideo&platform=all)
- [Does the SDK support automatic reconnection after disconnection?](https://doc-zh.zego.im/faq/reconnect?product=ExpressVideo&platform=all)
- [In live scenarios, how to listen to events of remote audience role users logging in/logout from the room?](https://doc-zh.zego.im/faq/audience_event?product=ExpressVideo&platform=all)
- [How to adjust the camera focal length (zoom function)?](https://doc-zh.zego.im/faq/express_adjust_focal?product=ExpressVideo&platform=all)

- [Why can't I open the camera?](https://doc-zh.zego.im/faq/camera?product=ExpressVideo&platform=all)

- [How to ensure smooth audio and video in poor network environments (traffic control function)?](https://doc-zh.zego.im/faq/flowcontrol?product=ExpressVideo&platform=all)


- [Why does audio and video capture become invalid after Android 9 app locks screen or switches to background](https://doc-zh.zego.im/faq/android_background)
- [How to keep ZEGO SDK audio and video functions running normally when the app goes to background?](/faq/audio-video-background-keep-alive)
