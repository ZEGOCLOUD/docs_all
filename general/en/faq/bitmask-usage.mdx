---

date: "2021-12-04"
ce-comparison:
  - "如何:how"
  - "使用:use"
  - "位掩码:bitmask"
---
import { Title } from './title';
import ArticleMetadata from '../../zh/faq/ArticleMetadata';

<Title>How to use bitmask?</Title>

<ArticleMetadata language="en" product="Video Call / Audio Call / Live streaming / Interactive whiteboard / File sharing / AI Effects / Cloud recording / Local server recording / Screen sharing / Mini program live streaming / GO Class / In-app chat / Super Board / Live streaming" platform="iOS / Android / macOS / Windows / Linux" />




---

## Application Scenarios

All numbers in a program are stored in binary form in computer memory, and bitwise operations directly operate on the binary bits of integers in memory.

| Symbol|  Meaning  |  Operation Rule | Example |
|---------|--------|--------|--------|
| & | AND | The result is 1 only when both bits are 1. | 0&1=0, 1&1=1. |
| ｜ | OR | The result is 0 only when both bits are 0. | 0｜0=0, 0｜1=1. |
| ^ | XOR |  The result is 0 when the two bits are the same, and 1 when they are different. | 1^1=0, 0^1=1. |
| ~ | NOT | 0 becomes 1, 1 becomes 0. |~1=0, ~0=1.|
|  \<\<  | Left Shift   | Shift all numbers to the left by the corresponding number of bits in binary form, the high bits are shifted out (discarded), and the low bits are filled with zeros.   | For example, the binary of integer 3 is 00000011, 3 \<< 2 means shifting the binary bits of number 3 to the left by 2 bits, and the binary after shifting is 00001100.|
|  >>  | Signed Right Shift   |  Shift all numbers to the right by the corresponding number of bits in binary form, the low bits are shifted out (discarded), and the high bits are filled with the sign bit, that is, positive numbers are filled with zeros, and negative numbers are filled with 1. |  For example, the binary of integer 3 is 00000011, 3 >> 1 means shifting the binary bits of number 3 to the right by 1 bit with sign, and the binary after shifting is 00000001.  |
|  >>>  | Unsigned Right Shift   |  Shift all numbers to the right by the corresponding number of bits in binary form, the low bits are shifted out (discarded), and the high bits are filled with zeros. For positive numbers, it is the same as the signed right shift rule, but for negative numbers, it is different.  | For example, the binary of integer 3 is 00000011, 3 >> 1 means shifting the binary bits of number 3 to the right by 1 bit with sign, and the binary after shifting is 00000001.  |

The SDK mainly uses the bitmask principle to implement the operation of multiple switches. That is, when the API needs to perform multiple selections of module switches, developers need to pass the bitmask result to the SDK.

## Operation Steps

Taking the function of obtaining raw audio and video data as an example, the bitmask usage examples for different languages are as follows:

- **C++**

```cpp
enum ZegoAudioDataCallbackBitMask
{
    /** This property controls whether the SDK calls the [onCapturedAudioData] method */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_CAPTURED = 1 << 0,

    /** This property controls whether the SDK calls the [onPlaybackAudioData] method */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_PLAYBACK = 1 << 1,

    /** This property controls whether the SDK calls the [onMixedAudioData] method */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_MIXED = 1 << 2,

    /** This property controls whether the SDK calls the [onPlayerAudioData] method */
    ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_PLAYER = 1 << 3
};

// Enable the SDK to obtain raw audio data function, specifying that the SDK needs to trigger both the captured audio data callback and the playback audio data callback
unsigned int bitmask = ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_CAPTURED | ZEGO_AUDIO_DATA_CALLBACK_BIT_MASK_PLAYBACK;
engine->startAudioDataObserver(bitmask, param);
```

- **Objective-C**

```objc
typedef NS_OPTIONS(NSUInteger, ZegoAudioDataCallbackBitMask) {
    /// This property controls whether the SDK calls the [onCapturedAudioData] method
    ZegoAudioDataCallbackBitMaskCaptured = 1 << 0,
    /// This property controls whether the SDK calls the [onPlaybackAudioData] method
    ZegoAudioDataCallbackBitMaskPlayback = 1 << 1,
    /// This property controls whether the SDK calls the [onMixedAudioData] method
    ZegoAudioDataCallbackBitMaskMixed = 1 << 2,
    /// This property controls whether the SDK calls the [onPlayerAudioData] method
    ZegoAudioDataCallbackBitMaskPlayer = 1 << 3
};

// Enable the SDK to obtain raw audio data function, specifying that the SDK needs to trigger both the captured audio data callback and the playback audio data callback
ZegoAudioDataCallbackBitMask bitmask = ZegoAudioDataCallbackBitMaskCaptured | ZegoAudioDataCallbackBitMaskPlayback;
[[ZegoExpressEngine sharedEngine] startAudioDataObserver:bitmask param:param];
```

- **Java**

```java
public enum ZegoAudioDataCallbackBitMask {
    /** This property controls whether the SDK calls the [onCapturedAudioData] method */
    CAPTURED(1 << 0),
    /** This property controls whether the SDK calls the [onPlaybackAudioData] method */
    PLAYBACK(1 << 1),
    /** This property controls whether the SDK calls the [onMixedAudioData] method */
    MIXED(1 << 2),
    /** This property controls whether the SDK calls the [onPlayerAudioData] method */
    PLAYER(1 << 3);
}

// Enable the SDK to obtain raw audio data function, specifying that the SDK needs to trigger both the captured audio data callback and the playback audio data callback
int bitmask = 0;
bitmask |= ZegoAudioDataCallbackBitMask.CAPTURED.value();
bitmask |= ZegoAudioDataCallbackBitMask.PLAYBACK.value();
engine.startAudioDataObserver(bitmask, param);
```


